static pointer (*ftab[13])();

#define QUOTE_STRINGS_SIZE 518
static char *quote_strings[QUOTE_STRINGS_SIZE]={
    "prin1-to-string",
    "position",
    "string",
    ":ftab-index",
    "ftab-next",
    "external-functions",
    ":clearpush",
    "\"~A:~%\"",
    "\"/*\"",
    "\"*/\"",
    "\"local[~d]\"",
    "\"	~A = ~A;~%\"",
    ":pop",
    "\"	local[~d]= ~A;~%\"",
    "\"w\"",
    ":push",
    "\"w\"",
    "\"local[~d]\"",
    "\"	ctx->vsp=local+~d;~%\"",
    ":store",
    "\"w\"",
    ":reset-vsp",
    "\"	bindspecial(ctx,fqv[~d],w);~%\"",
    ":quote-entry",
    "\"	unbindx(ctx,~d);~%\"",
    "\"env\"",
    ":comment",
    "\"static pointer ~A(ctx,n,argv,env)~%\"",
    "\"register context *ctx;~%\"",
    "\"register int n; register pointer argv[]; pointer env;~%\"",
    "\"{ register pointer *local=ctx->vsp, w, *fqv=qv;~%\"",
    "\"  numunion nu;~%\"",
    "*safety*",
    "\"	breakck;~%\"",
    "\"	if (n~A~d) maerror();~%\"",
    "\"!=\"",
    "\"<\"",
    "\"	if (n>=~d) { local[~d]=(argv[~d]); goto ~A;}~%\"",
    "\"	if (n>~d) maerror();~%\"",
    "\"minilist(ctx,&argv[n],n-~d)\"",
    "\"	n=parsekeyparams(fqv[~d], &argv[~d], n-~d, local+~d, ~A);~%\"",
    "\"	if (n & (1<<~A)) goto ~A;~%\"",
    "\"argv\"",
    "\"local\"",
    "\"env->\"",
    "\"c.clo.env0->\"",
    "\"c.clo.env1\"",
    "\"c.clo.env2\"",
    "\"T\"",
    "\"NIL\"",
    "\"makeint(~d)\"",
    "\"makeflt(~8,8e)\"",
    "\"fqv[~d]\"",
    "\"~A[~d]\"",
    ":getbase",
    "arg",
    "\"~A[~d]\"",
    "\"~A[0]->c.obj.iv[~d]\"",
    "\"loadglobal(fqv[~d])\"",
    "\"~A[~d]\"",
    "\"~A[~d]\"",
    "\"~A[0]->c.obj.iv[~d]\"",
    "\"	storeglobal(fqv[~d],~A);~%\"",
    "\"*(ovafptr(~A,fqv[~d]))\"",
    "\"~A->c.obj.iv[~d]\"",
    "\"*(ovafptr(~A,fqv[~A]))\"",
    "\"w\"",
    "\"w->c.obj.iv[~d]\"",
    "user-function-entry",
    "builtin-function-entry",
    "functionp",
    "*error-output*",
    "\"; ~C[34;7m~S~C[0;34m is assumed to be undefined function~C[0m~%\"",
    "\"	w=(pointer)~A(ctx,~d,local+~d); /*~A*/~%\"",
    "\"	w=(*ftab[~d])(ctx,~d,local+~d,&ftab[~d],fqv[~d]); /*~A*/~%\"",
    ":discard",
    "\"w\"",
    "\"w\"",
    "\"	w=~a(ctx,~d,local+~d,w);~%\"",
    "\"w\"",
    "\"(pointer)get_sym_func(fqv[~d])\"",
    "\"(pointer)((eusinteger_t)(~A)-4)\"",
    "\"(pointer)((eusinteger_t)(~A)+4)\"",
    "\"w\"",
    "\"	w=~a;~%\"",
    "\"	if (!iscons(w) && w!=NIL) error(E_NOLIST);~%\"",
    "\"w\"",
    "*optimize*",
    "\"xcar(~A)\"",
    ":check-cons-nil",
    "\"(~A)->c.cons.car\"",
    "\"xcdr(~A)\"",
    "\"(~A)->c.cons.cdr\"",
    "\"xcar(xcar(~A))\"",
    "\"(~A)->c.cons.car\"",
    "\"(~A)->c.cons.car\"",
    "\"(~A)->c.cons.car->c.cons.car\"",
    "\"xcdr(xcdr(~A))\"",
    "\"(~A)->c.cons.cdr\"",
    "\"(~A)->c.cons.cdr\"",
    "\"(~A)->c.cons.cdr->c.cons.cdr\"",
    "\"xcdr(xcar(~A))\"",
    "\"(~A)->c.cons.car\"",
    "\"(~A)->c.cons.cdr\"",
    "\"(~A)->c.cons.car->c.cons.cdr\"",
    "\"xcadr(~A)\"",
    "\"(~A)->c.cons.cdr\"",
    "\"(~A)->c.cons.car\"",
    "\"(~A)->c.cons.cdr->c.cons.car\"",
    "\"xcadr(xcdr(~A))\"",
    "\"(~A)->c.cons.cdr\"",
    "\"(~A)->c.cons.cdr\"",
    "\"(~A)->c.cons.car\"",
    "\"(~A)->c.cons.cdr->c.cons.cdr->c.cons.car\"",
    "\"w\"",
    "\"cons(ctx,~A,w)\"",
    "\"	{ register eusinteger_t i=intval(~A);~%\"",
    "\"	  w=(~A->c.vec.v[i]);}~%\"",
    "\"w\"",
    "\"w\"",
    "\"	{ register eusinteger_t i; register pointer v;~%\"",
    "\"	  i=intval(~A); v=~A;~%\"",
    "\"	  v->c.vec.v[i]=w;}~%\"",
    "\"w\"",
    "\"	{ register eusinteger_t i=intval(~A);~%\"",
    "\"	  w=makeint(~A->c.str.chars[i]);}~%\"",
    "\"w\"",
    "\"w\"",
    "\"	{ register eusinteger_t i; register pointer v;~%\"",
    "\"	  i=intval(~A); v=~A;~%\"",
    "\"	  v->c.str.chars[i]=intval(w);}~%\"",
    "\"w\"",
    "\"	{ register eusinteger_t i=intval(~A);~%\"",
    "\"	  w=makeint(~A->c.str.chars[i/8]&(1<<(i&7))?1:0);}~%\"",
    "\"w\"",
    "\"w\"",
    "\"	{ register eusinteger_t i; register byte *v;~%\"",
    "\"	  i=intval(~A); v=~A->c.str.chars;~%\"",
    "\"	  if (((eusinteger_t)w)&4) v[i/8]|=(1<<(intval(i)&7));~%\"",
    "\"	  else v[i/8]&= ~~(1<<(intval(i)&7));}~%\"",
    "\"w\"",
    "\"	{ register eusinteger_t i=intval(~A);~%\"",
    "character",
    "\"	  w=makeint(~A->c.str.chars[i]);}~%\"",
    "integer",
    "\"	  w=makeint(~A->c.ivec.iv[i]);}~%\"",
    "float",
    "\"	  w=makeflt(~A->c.fvec.fv[i]);}~%\"",
    "pointer",
    "\"	  w=(~A->c.vec.v[i]);}~%\"",
    ":error",
    "\"unknown vector element type\"",
    "\"w\"",
    "\"w\"",
    "\"	{ register eusinteger_t i; register pointer v;~%\"",
    "\"	  i=intval(~A); v=~A;~%\"",
    "\"	  v->c.str.chars[i]=intval(w);}~%\"",
    "\"	  v->c.ivec.iv[i]=intval(w);}~%\"",
    "\"	  v->c.fvec.fv[i]=fltval(w);}~%\"",
    "\"	  v->c.vec.v[i]=w;}~%\"",
    "\"unknown vector element type\"",
    "\"w\"",
    "\"((~A)==NIL?T:NIL)\"",
    "\"((~A)==(~A)?T:NIL)\"",
    "\"w\"",
    "\"memq(~A,w)\"",
    "\"w\"",
    "\"(~A(w)?T:NIL)\"",
    "((symbolp . \"issymbol\") (consp . \"iscons\") (numberp . \"isnum\") (integerp . \"isint\") (floatp . \"isflt\") (stringp . \"isstring\"))",
    "assoc",
    "\"	if (~A==NIL) goto ~A;~%\"",
    "\"	if (~A!=NIL) goto ~A;~%\"",
    "\"	if (~A==~A) goto ~A;~%\"",
    "\"	if (~A!=~A) goto ~A;~%\"",
    "(+ - logand logior)",
    "\"w\"",
    "(+ -)",
    "\"#if sun4 || vax || mips || i386 || alpha || x86_64 || ARM~%	w=(pointer)((eusinteger_t)w-2);~%#endif~%\"",
    "\"(pointer)((eusinteger_t)~A ~A (eusinteger_t)w)\"",
    "((+ . \"+\") (- . \"-\") (logand . \"&\") (logior . \"|\"))",
    "\"	{ eusinteger_t i,j;~%\"",
    "\"		j=intval(~A); i=intval(~A);~%\"",
    "\"		local[~d]=(makeint(i ~A j));}~%\"",
    "((+ . \"+\") (- . \"-\") (logand . \"&\") (logior . \"|\") (* . \"*\"))",
    "\"makeint(-(intval(~A)))\"",
    "\"makeint(abs(intval(~A)))\"",
    "\"makeflt((double)fabs(fltval(~A)))\"",
    "<>",
    ":if-neq",
    "=",
    ":if-eq",
    "int",
    "\"w\"",
    "\"	if ((eusinteger_t)~A ~A (eusinteger_t)w) goto ~A;~%\"",
    "\"	{ double left,right;~%\"",
    "\"		right=fltval(~A); left=fltval(~A);~%\"",
    "\"	if (left ~A right) goto ~A;}~%\"",
    "\"illegal compare\"",
    "\"	{ double x,y;~%\"",
    "\"		y=fltval(~A); x=fltval(~A);~%\"",
    "\"		local[~d]=(makeflt(x ~A y));}~%\"",
    "((+ . +) (- . -) (* . *) (/ . /))",
    "\"makeflt(-(fltval(~A)))\"",
    "((symbolp . \"issymbol\") (integerp . \"isint\") (numberp . \"isnum\") (floatp . \"isflt\") (atom . \"!iscons\") (consp . \"iscons\") (stringp . \"isstring\"))",
    "\"w\"",
    "\"	if (~A(w)) goto ~A;~%\"",
    ":type-checker",
    "\"w\"",
    "\"	if (!~A(w)) goto ~A;~%\"",
    "\"	goto ~A;~%\"",
    "\"	ctx->vsp=local; return(local[0]);}~%\"",
    "\":return pushcount is ~d \"",
    "warn",
    "\"w\"",
    "\"w\"",
    "\"	{jmp_buf jb;~%\"",
    "\"w\"",
    "\"	mkcatchframe(ctx,w,(jmp_buf *)jb);~%\"",
    "\"	if ((w=(pointer)eussetjmp(jb))!=0) { /*fsp=vsp;*/ goto ~A;}~%\"",
    "\"w\"",
    ":label",
    "\"	if (w==(pointer)(1)) w=makeint(0);~%\"",
    "\"	restorecatch(ctx);};~%\"",
    "\"w\"",
    "\"w\"",
    "\"	throw(ctx,vpop(),w);~%\"",
    "\"	error(E_NOCATCHER,NULL);~%\"",
    "\"w\"",
    "\"	local[~d]=(pointer)(ctx->protfp); local[~d]=w;\n	ctx->protfp=(struct protectframe *)(local+~d);~%\"",
    "\"w\"",
    "\"	~A(ctx,0,local+~d,ctx->protfp->cleaner);~%\"",
    "\"	ctx->protfp=ctx->protfp->protlink;~%\"",
    "\"w\"",
    "\"w\"",
    "\"	unwind(ctx,local+~d);~%\"",
    "\"	local[~d]=w;~%\"",
    "\"	unwind(ctx,local+~d);~%\"",
    "\"makeclosure(codevec,quotevec,~A,env,argv,local)\"",
    "\"	compfun(ctx,fqv[~d],module,~A,fqv[~d]);~%\"",
    "\"	compmacro(ctx,fqv[~d],module,~A,fqv[~d]);~%\"",
    "\"NIL\"",
    "\"fqv[~d]\"",
    "\"	addcmethod(ctx,module,~A,fqv[~d],fqv[~d],~A);~%\"",
    ":quote-fqv-entry",
    "\"static pointer ~A();~%\"",
    ":direction",
    ":output",
    "open",
    "\"/* ~a :  entry=~a */~%\"",
    "namestring",
    "\"/* compiled by ~a */~%\"",
    "lisp-implementation-version",
    "\"#include \\\"eus.h\\\"~%\"",
    "\"#include \\\"~A.~A\\\"~%\"",
    "pathname-name",
    "pathname-type",
    "\"#pragma init (register_~a)~%\"",
    "\"extern double fabs();~%\"",
    "\"extern pointer fcallx();~%\"",
    "\"static void init_ftab();~%\"",
    "\"#define loadglobal(s) s->c.sym.speval~%\"",
    "\"#define storeglobal(s,val) s->c.sym.speval=(val)~%\"",
    "\"extern pointer loadglobal(),storeglobal();~%\"",
    "\"static pointer module,*qv,codevec,quotevec;~%\"",
    "lisp::solaris2",
    "*features*",
    "\"static pointer ___~a();~%\"",
    "\"extern pointer ___~a();~%\"",
    "\"extern pointer build_quote_vector();~%\"",
    "\"static int register_~a()~%\"",
    "\"  { add_module_initializer(~s, ___~a);}~%~%\"",
    "\"___\"",
    "*defun-list*",
    "\"static pointer ~a();~%\"",
    "\"~%/* initializer*/~%pointer ___~A(ctx,n,argv,env)\nregister context *ctx; int n; pointer *argv; pointer env;~%\"",
    "\"{ register pointer *local=ctx->vsp, w, *fqv;~%  register int i;~%\"",
    "\"  numunion nu;~%\"",
    "\"  module=argv[0];~%\"",
    "\"  quotevec=build_quote_vector(ctx,QUOTE_STRINGS_SIZE, quote_strings);~%\"",
    "\"  module->c.code.quotevec=quotevec;~%\"",
    "\"  codevec=module->c.code.codevec;~%\"",
    "\"  fqv=qv=quotevec->c.vec.v;~%\"",
    "\"  init_ftab();~%\"",
    "\"#define QUOTE_STRINGS_SIZE ~d~%\"",
    "\"~astatic char *quote_strings[QUOTE_STRINGS_SIZE]={~%\"",
    ":solaris2",
    "\"const \"",
    "\"\"",
    "\"    \\\"\"",
    "\"\\\\\\\"\"",
    "\"\\\\n\"",
    "\"\\\",~%\"",
    "\"  };~%\"",
    "\"static pointer (*ftab[~d])();~%~%\"",
    "\"static void init_ftab()~%{\"",
    "\"  register int i;~%\"",
    "\"  for (i=0; i<~d; i++) ftab[i]=fcallx;~%\"",
    "\"}~%\"",
    "remprop",
    "\"COMPILER\"",
    "\"COMPILER\"",
    "*package*",
    "\"no such package\"",
    "trans",
    ":vtype",
    ":global",
    "c-stringize",
    "\"(x)\"",
    "translator",
    ":super",
    "object",
    ":slots",
    "(cfile hfile push pushcount quotev)",
    ":metaclass",
    ":element-type",
    ":size",
    ":documentation",
    "make-class",
    "ftab-index",
    "\"(sym)\"",
    "\"(self class l)\"",
    "\"(self class &rest c)\"",
    "\"(self class)\"",
    "\"(self class dest)\"",
    "\"(self class src)\"",
    "\"(self class)\"",
    "\"(self class q)\"",
    ":dupe",
    "\"(self class)\"",
    "\"(self class n)\"",
    ":adjust",
    "\"(self class n)\"",
    ":setpushcount",
    "\"(self class n)\"",
    ":offset-from-fp",
    "\"(self class)\"",
    "\"(self class)\"",
    ":bind-special",
    "\"(self class id)\"",
    ":unbind-special",
    "\"(self class count)\"",
    ":pushenv",
    "\"(self class)\"",
    ":enter",
    "\"(self class cname lname)\"",
    ":check-req-arg",
    "\"(self class req opt)\"",
    ":check-opt-arg",
    "\"(self class m lab)\"",
    ":check-rest-arg",
    "\"(self class m)\"",
    ":rest",
    "\"(self class pcnt)\"",
    ":parse-key-params",
    "\"(self class keyvec req+opt keyn allowotherkeys)\"",
    ":check-key-arg",
    "\"(self class n lab)\"",
    "\"(self class n argp)\"",
    ":load-t",
    "\"(self class)\"",
    ":load-nil",
    "\"(self class)\"",
    ":load-int",
    "\"(self class x)\"",
    ":load-float",
    "\"(self class x)\"",
    ":load-quote",
    "\"(self class ent)\"",
    ":load-arg",
    "\"(self class n level)\"",
    ":load-local",
    "\"(self class n level)\"",
    ":load-obj",
    "\"(self class n level)\"",
    ":load-global",
    "\"(self class ent)\"",
    ":store-arg",
    "\"(self class n level)\"",
    ":store-local",
    "\"(self class offset level)\"",
    ":store-obj",
    "\"(self class var level)\"",
    ":store-global",
    "\"(self class var)\"",
    ":load-ovaf",
    "\"(self class var)\"",
    ":load-indexed-ov",
    "\"(self class index)\"",
    ":store-ovaf",
    "\"(self class var)\"",
    ":store-indexed-ov",
    "\"(self class index)\"",
    ":call",
    "\"(self class sym n)\"",
    ":call-closure",
    "\"(self class entry argc)\"",
    ":getfunc",
    "\"(self class sym)\"",
    ":1-",
    "\"(self class)\"",
    ":1+",
    "\"(self class)\"",
    "\"(self class)\"",
    ":car",
    "\"(self class)\"",
    ":cdr",
    "\"(self class)\"",
    ":caar",
    "\"(self class)\"",
    ":cddr",
    "\"(self class)\"",
    ":cdar",
    "\"(self class)\"",
    ":cadr",
    "\"(self class)\"",
    ":caddr",
    "\"(self class)\"",
    ":cons",
    "\"(self class)\"",
    ":svref",
    "\"(self class)\"",
    ":svset",
    "\"(self class)\"",
    ":char",
    "\"(self class)\"",
    ":setchar",
    "\"(self class)\"",
    ":bit",
    "\"(self class)\"",
    ":setbit",
    "\"(self class)\"",
    ":vref",
    "\"(self class type)\"",
    ":vset",
    "\"(self class type)\"",
    ":nullx",
    "\"(self class)\"",
    ":eqx",
    "\"(self class)\"",
    ":memqx",
    "\"(self class)\"",
    ":type-check-predicate",
    "\"(self class pred)\"",
    ":if-nil",
    "\"(self class lab)\"",
    ":if-t",
    "\"(self class lab)\"",
    "\"(self class lab)\"",
    "\"(self class lab)\"",
    ":int-op2",
    "\"(self class op)\"",
    ":int-neg",
    "\"(self class)\"",
    ":int-abs",
    "\"(self class)\"",
    ":flt-abs",
    "\"(self class)\"",
    ":compare",
    "\"(self class type comparator lab)\"",
    ":flt-op2",
    "\"(self class op)\"",
    ":flt-neg",
    "\"(self class)\"",
    "\"(self class tn)\"",
    ":if-type",
    "\"(self class type lab)\"",
    ":if-not-type",
    "\"(self class type lab)\"",
    ":jump",
    "\"(self class lab)\"",
    ":return",
    "\"(self class)\"",
    ":del-frame",
    "\"(self class spe loc)\"",
    ":entercatch",
    "\"(self class exit)\"",
    ":exitcatch",
    "\"(self class exlab)\"",
    ":throw",
    "\"(self class)\"",
    ":bind-cleaner",
    "\"(self class)\"",
    ":call-cleaner",
    "\"(self class cleaner)\"",
    ":return-from",
    "\"(self class k need-unwind)\"",
    ":go-tag",
    "\"(self class k need-unwind)\"",
    ":closure",
    "\"(self class lab)\"",
    ":defun",
    "\"(self class sym cname doc)\"",
    ":defmacro",
    "\"(self class sym label doc)\"",
    "\"(self class q)\"",
    ":defmethod",
    "\"(self class klass sel label doc)\"",
    ":declare-forward-function",
    "\"(self class name)\"",
    ":quote",
    "\"(self class)\"",
    ":init",
    "\"(self class)\"",
    ":init-file",
    "\"(self class source-name cname hname entry)\"",
    ":eusmain",
    "\"(self class entry)\"",
    ":write-quote-vector",
    "\"(self class)\"",
    ":declare-ftab",
    "\"(self class)\"",
    ":ftab-initializer",
    "\"(self class)\"",
    ":close",
    "\"(self class)\"",
    ":trans",
    "\"$Id$\"",
    "provide",
  };

ファイルを多重にロードする場合の不便を解消するために
provide, require 関数を加え、loadに変更を加えました。


1. provide and require

provide, require 関数は、すでにロード済みのモジュール名のリストである
*modules* 変数を参照します。いずれの場合もmoduleはストリングまたはシ
ンボルで、最終的には大文字のストリングに変換されます。

requireは、(require module-name &optional file-name) の形式をしており、
*modules*にmodule-nameが含まれていない場合に限りfile-nameをロードし、
module-nameを*modules*に加えます。file-nameが指定されていない場合は何も
しません。

provideは、(provide module-name) の形式で、単にmodule-nameを*modules*に
加え(adjoin)ます。

使い方:
file A が基本関数を含んだファイル、B,Cがそれを参照するプログラムだとします。
つまり、BとCの動作にはAが必要ですが、BとCは独立で、相互参照はないとします。

A の中で、(provide 'A) します。
BとCの先頭では、(require 'A "a.o") とします。

provide, requireがない場合、B、Cの先頭で(load "a.o")することになります。
ここで、たまたまBとCを続けてロードすると、"a.o"を2回ロードすることになり、
時間がかかるだけでなく、別のインスタンスが作られて困ることがあります。
requireにしておけば"a.o"のロードは一回だけ行われます。
また、Bがデバッグ中で頻繁にロードを繰り返す場合でも、requireを使えば
すでにロードされた"a.o"を何回がロードされることを防ぐことができます。
ただし、Aに変更を加えて、本当に"a.o"をロードし直す必要があるときは、
陽に(load "a")しなければなりません。

*modules* の値を見れば、今までにどんなモジュールがロードされたかが
わかります。

2. load

requireの二つめの引数は、モジュールを定義しているファイル名です。
ファイル中から他のファイルをロードする場合、それも他のディレクトリ
にある場合、相対パス指定をしたくなりますが、それはできません。
(load ...) は、C の#include とは違って単一のファイルだけを参照する
のでなく、.q, .o, .l, *symbol-input*, *symbol-output*, :ld-option
などたくさんのファイルを探すので、loadの最初にchdirしておけばよい
というわけにはいかないからです。

しかし、これでは不便なので、loadの最初で、そのファイルがあるディレク
トリを *load-path*に一時的に追加するようにしました。相対パス指定は
できませんが、そのディレクトリにある他のモジュールをロードする場合
に限り、絶対パスを書かなくても確実にロードできるようになります。

homeにいて、サブディレクトリ中のファイル "sub/file.l"をロード
するとします。

file.lが
(require 'module "module")
...

となっていると、以前は、"module"は homeにあるか、*load-path*中の
どこかになければならなかったのですが、subにあってもよいことになります。





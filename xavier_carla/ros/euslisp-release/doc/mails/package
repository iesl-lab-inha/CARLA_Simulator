一部から文句の出ていたPackageを、Common Lispの仕様に沿うよう
作り替えました。大きな違いは、外部シンボルと内部シンボルの
区別ができたことです。今までは、すべてのシンボルを外部シンボル
すなわちexportされたシンボルとして扱い、なおかつpackage を
useした時点でのシンボルの衝突を気にしないでいましたが、これからは
厳格な検査が行なわれます。

readによって最初に読み込まれたシンボルは、内部シンボルとして
packageにinternされます。これを外部シンボルにするには、その
パッケージからexportします。

ユーザは、いつの時点でも、どれか一つのパッケージの中にいます。
デフォルトは"USER" packageです。Lispの関数は"LISP"パッケージに、
幾何関数は"GEOMETRY"に、"UNIX","SYSTEM"パッケージにはシステム
管理の関数が入っています。current packageは、*package*変数に
記録されています。Current packageの中のシンボルは、何も気にせず
に使えます。ETALispなどのパッケージがないシステムと同じです。

あるパッケージは、他のパッケージをuseできます。useすると、
そのパッケージの中の、外部シンボルが、あたかも自分のパッケージの
中にあるかのように利用できます。USERパッケージは、LISP, GEOMETRY
をuseしているので、これらの関数が簡単に使えるわけです。

useが、パッケージの外部シンボルをそっくり取り込むのに対し、個々の
シンボルを取り込むのがimportです。importが取り込むシンボルは、
exportされている必要はありません。exportされているかどうかと
いうのは、パッケージ側に記録される属性であって、シンボルの
属性ではありません。ただし、シンボルには、home-packageという
属性があります。これは、シンボルが最初に定義されたパッケージです。
たとえば、パッケージAにexportされていないシンボルSがあるとします。
パッケージBでこれをimportし、さらにexportすることができます。
これをパッケージCで見ると、同一のシンボルが、A::S, B:Sとして
見えることになります。

このように、use, importがあるのは、プログラムの表記を簡単にし、
パッケージを使わない旧来のプログラムとの互換性を保つためです。

パッケージpppのシンボルsssは、もしそれがexportされていれば、ppp:sss
exportされていなければ、ppp::sssとして参照できます。これは、カレントな
パッケージが何であるかに関係しません。一方、カレントなパッケージが
pppであれば、このppp: およびppp:: は省略することができます。
さらに、importされたシンボル、useされたパッケージの外部シンボルは
これらのprefixを省略することができます。

CommonLispがpackageを設けた目的は、大規模なソフトウェアを多人数で
開発するような場合に、名前の空間を複数用意することで、関数名、変数名
が衝突することを避けるためでした。したがって、パッケージをuseしたり
シンボルをimport, exportする場合は、名前の衝突がないことを検査する
必要があります。





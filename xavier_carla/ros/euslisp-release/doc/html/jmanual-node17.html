<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//JP">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>幾何学モデリング</TITLE>
<META NAME="description" CONTENT="幾何学モデリング">
<META NAME="keywords" CONTENT="jmanual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="next" HREF="jmanual-node18.html">
<LINK REL="previous" HREF="jmanual-node16.html">
<LINK REL="up" HREF="jmanual-node13.html">
<LINK REL="next" HREF="jmanual-node18.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<BR>
<B> Next:</B> <A NAME="tex2html793"
  HREF="jmanual-node18.html">視界とグラフィックス</A>
<B>Up:</B> <A NAME="tex2html787"
  HREF="jmanual-node13.html">EusLisp 拡張</A>
<B> Previous:</B> <A NAME="tex2html781"
  HREF="jmanual-node16.html">幾何学関数</A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html794"
  HREF="jmanual-node17.html#SECTION03041000000000000000">種々の幾何学関数</A>
<LI><A NAME="tex2html795"
  HREF="jmanual-node17.html#SECTION03042000000000000000">線とエッジ</A>
<LI><A NAME="tex2html796"
  HREF="jmanual-node17.html#SECTION03043000000000000000">平面と面</A>
<LI><A NAME="tex2html797"
  HREF="jmanual-node17.html#SECTION03044000000000000000">立体(body)</A>
<LI><A NAME="tex2html798"
  HREF="jmanual-node17.html#SECTION03045000000000000000">基本bodyの作成関数</A>
<LI><A NAME="tex2html799"
  HREF="jmanual-node17.html#SECTION03046000000000000000">bodyの合成関数</A>
<LI><A NAME="tex2html800"
  HREF="jmanual-node17.html#SECTION03047000000000000000">座標軸</A>
<LI><A NAME="tex2html801"
  HREF="jmanual-node17.html#SECTION03048000000000000000">立体の接触状態解析</A>
<LI><A NAME="tex2html802"
  HREF="jmanual-node17.html#SECTION03049000000000000000">多角形のVoronoi Diagram</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION03040000000000000000"></A><A NAME="Geometry"></A>
<BR>
幾何学モデリング
</H1>

<P>
Euslispは、３次元の幾何学モデルの内部表現として<A NAME="31738"></A><EM>B</EM>rep（境界表現）を採用している。
Brep内の要素は<B>edge, plane, polygon, face, hole,</B>や<B>body</B>クラスによって
表現される。
基本bodyの作成関数とbodyの合成関数は、これらのクラスの新しい
インスタンスを作る。
もっと属性を持った独自の幾何学クラスを使用するためには、
<B>*edge-class*, *face-class*</B>と<B>*body-class*</B>の特殊変数に
独自のクラスオブジェクトを設定すること。

<P>

<DIV ALIGN="CENTER"><A NAME="30729"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 9:</STRONG>
頂点とエッジと面の分類</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="505" HEIGHT="444" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img85.png"
 ALT="\includegraphics[height=10cm]{fig/beam.ps}">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION03041000000000000000">
種々の幾何学関数</A>
</H2>

<P>

 <BR>
<BR> <P>

<A NAME="31740"></A>
<B>vplus</B> <EM>vector-list </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>vector-list</EM>のすべての要素の合計を実数ベクトルとして
新しく作り、返す。
<B>v+</B>との違いは、<B>vplus</B>が2つ以上の引数について合計を計算し、
結果のベクトルが指定できない点である。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31753"></A>
<B>vector-mean</B> <EM>vector-list </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>vector-list</EM>の平均ベクトルを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31764"></A>
<B>triangle</B> <EM>a b c &amp;optional (normal #f(0 0 1)) </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>a, b, c</EM>は、2次元または3次元の実数ベクトルである。
<EM>normal</EM>は、<EM>a,b,c</EM>が置かれる平面の正規ベクトルである。
<B>triangle</B>は<EM>a,b,c</EM>で形作られる三角形の領域の2倍の大きさを返す。
<EM>normal</EM>と同じ方向から見たときに<EM>a,b,c</EM>が時計方向に回転する
ならば、<B>triangle</B>は正である。
言い換えると、もし<B>triangle</B>が正ならば、
<EM>c</EM>は<EM>a-b</EM>の線分の左手側に位置し、
<EM>b</EM>は<EM>a-c</EM>の右手側に位置している。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31787"></A>
<B>triangle-normal</B> <EM>a b c </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>a b c</EM>で定義される三角形に対して垂直方向の正規ベクトルを見つける。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31798"></A>
<B>vector-angle</B> <EM>v1 v2 &amp;optional (normal (v* v1 v2)) </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
2つのベクトルの角度を計算する。
これは次の式であらわされる<TT>atan(normal<SPAN CLASS="MATH"><IMG
 WIDTH="7" HEIGHT="9" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img86.png"
 ALT="$ \cdot$"></SPAN>(v1<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img48.png"
 ALT="$ \times$"></SPAN>v2), v1<SPAN CLASS="MATH"><IMG
 WIDTH="7" HEIGHT="9" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img86.png"
 ALT="$ \cdot$"></SPAN>v2)</TT>。
<EM>v1,v2</EM>と<EM>normal</EM>は正規ベクトルでなければならない。
<EM>normal</EM>が与えられないとき、<EM>v1,v2</EM>の共通垂線の正規ベクトルが
使用される。この場合、結果は<SPAN CLASS="MATH">0</SPAN>から<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="11" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img10.png"
 ALT="$ \pi$"></SPAN>までの範囲の正の角度になる。
符号付きの角度を得るためには、<EM>normal</EM>を指定しなければならない。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31814"></A>
<B>face-normal-vector</B> <EM>vertices </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
同じ平面の上にあるベクトルのリストから面の正規化ベクトルを計算する。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31824"></A>
<B>farthest</B> <EM>p points </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
3次元ベクトルのリスト<EM>points</EM>の中から<EM>p</EM>より最も遠い点を捜す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31836"></A>
<B>farthest-pair</B> <EM>points </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
3次元ベクトルのリスト<EM>points</EM>からもっとも遠い点の組を
捜す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31847"></A>
<B>maxindex</B> <EM>3D-floatvec </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>3D-floatvec</EM>の3つの要素の中で絶対値が最大の要素の位置を捜す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31858"></A>
<B>random-vector</B> <EM>&amp;optional (range 1.0) </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
3次元デカルト空間の中で同次的に分散されるランダムベクトルを発生する。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31868"></A>
<B>random-normalized-vector</B> <EM>&amp;optional (range 1.0) </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
3次元の正規化ランダムベクトルを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31878"></A>
<B>random-vectors</B> <EM>count range </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>range</EM>の大きさのランダムベクトルを<EM>count</EM>個つくり、そのリストを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31890"></A>
<B>line-intersection</B> <EM>p1 p2 p3 p4 </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>p1, p2, p3, p4</EM>は、すべて2次元以上の実数ベクトルである。
<EM>p1-p2</EM>と<EM>p3-p4</EM>が平面上の2つの線分として定義される。
<B>line-intersection</B>は、これらの2つの線分の交差する点のパラメータ（線分に置ける
交点の位置の比率）を2要素のリストで返す。3次元で使用するとき、
<EM>p1, p2, p3, p4</EM>は共通平面内になければならない。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31905"></A>
<B>collinear-p</B> <EM>p1 p2 p3 &amp;optional tolerance </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>p1, p2, p3</EM>は、すべて3次元の実数ベクトルで3つの点を表現している。
<B>collinear-p</B>は、もし<TT><SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img87.png"
 ALT="$ \Vert$"></SPAN>((p2<SPAN CLASS="MATH"><IMG
 WIDTH="408" HEIGHT="874" BORDER="0"
 SRC="jmanual-img3.png"
 ALT="\begin{figure}\small
\begin{verbatim}object
cons
queue
propertied-object
s...
...h-table
surrounding-box
stereo-viewing\end{verbatim}
\normalsize\end{figure}"></SPAN>p1)<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img48.png"
 ALT="$ \times$"></SPAN>(p3<SPAN CLASS="MATH"><IMG
 WIDTH="408" HEIGHT="874" BORDER="0"
 SRC="jmanual-img3.png"
 ALT="\begin{figure}\small
\begin{verbatim}object
cons
queue
propertied-object
s...
...h-table
surrounding-box
stereo-viewing\end{verbatim}
\normalsize\end{figure}"></SPAN>p1))<SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img87.png"
 ALT="$ \Vert$"></SPAN></TT>が
<TT>*coplanar-threshold*</TT>より小さければ、<EM>p1-p3</EM>の線分の上に
<EM>p2</EM>を投影したときのパラメータを返す。そうでなければ、NILを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31921"></A>
<B>find-coplanar-vertices</B> <EM>p1 p2 p3 vlist </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>p1, p2, p3</EM>は、3次元の実数ベクトルで、この3つのベクトルから平面を表現している。
<B>find-coplanar-vertices</B>は、その平面内にある点を
<EM>vlist</EM>の中から捜す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31934"></A>
<B>find-connecting-edge</B> <EM>vertex edgelist </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>vertex</EM>に接続された<EM>edgelist</EM>の中からエッジを捜す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31946"></A>
<B>make-vertex-edge-htab</B> <EM>bodfacs </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>bodfacs</EM>は、<B>body</B>あるいは<B>face</B>のリストである。
<B>make-vertex-edge-htab</B>は、<EM>bodfacs</EM>の中の頂点を抽出し、それに接続されるエッジの検索ができる
ハッシュテーブルを作る。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31961"></A>
<B>left-points</B> <EM>points p1 p2 normal </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>points, p1, p2</EM>は、正規化ベクトル<EM>normal</EM>で表現される
平面内にあるものと仮定する。
<B>left-points</B>は、<EM>p1, p2</EM>間の線分の左側に置かれている点を
<EM>points</EM>の中から捜し、集める。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31976"></A>
<B>right-points</B> <EM>points p1 p2 normal </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>points, p1, p2</EM>は、正規化ベクトル<EM>normal</EM>で表現される
平面内にあるものと仮定する。
<B>right-points</B>は、<EM>p1, p2</EM>間の線分の右側に置かれている点を
<EM>points</EM>の中から捜し、集める。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="31991"></A>
<B>left-most-point</B> <EM>points p1 p2 normal </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>points, p1, p2</EM>は、正規化ベクトル<EM>normal</EM>で表現される
平面内にあるものと仮定する。
<B>left-most-points</B>は、<EM>p1, p2</EM>で決定される線分の左側に置かれている点を
<EM>points</EM>の中から捜し、その中でもっとも遠い点を返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32006"></A>
<B>right-most-point</B> <EM>points p1 p2 normal </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>points, p1, p2</EM>は、正規化ベクトル<EM>normal</EM>で表現される
平面内にあるものと仮定する。
<B>right-most-points</B>は、<EM>p1, p2</EM>で決定される線分の右側に置かれている点を
<EM>points</EM>の中から捜し、その中でもっとも遠い点を返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32021"></A>
<B>eps=</B> <EM>num1 num2 [(tolerance *epsilon*)] </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
2つの実数<EM>num1</EM>と<EM>num2</EM>を比較して、<EM>torelance</EM>の誤差範囲内で
等しいかどうかを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32034"></A>
<B>eps<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img6.png"
 ALT="$ &lt;$"></SPAN></B> <EM>num1 num2 [(tolerance *epsilon*)] </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>num1</EM>が明らかに<EM>num2</EM>よりも小さいときTを返す。すなわち、
<TT>num1<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img6.png"
 ALT="$ &lt;$"></SPAN>num2-tolerance</TT>である。
</DD>
</DL>
<BR>
<BR>

<A NAME="32047"></A>
<B>eps<SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img17.png"
 ALT="$ &lt;=$"></SPAN></B> <EM>num1 num2 [(tolerance *epsilon*)] </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>num1</EM>が多分<EM>num2</EM>よりも小さいときあるいは等しいときTを返す。すなわち、
<TT>num1<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img6.png"
 ALT="$ &lt;$"></SPAN>num2+tolerance</TT>である。
</DD>
</DL>
<BR>
<BR>

<A NAME="32060"></A>
<B>eps<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img15.png"
 ALT="$ &gt;$"></SPAN></B> <EM>num1 num2 [(tolerance *epsilon*)] </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>num1</EM>が明らかに<EM>num2</EM>よりも大きいときTを返す。すなわち、
<TT>num1<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img15.png"
 ALT="$ &gt;$"></SPAN>num2+tolerance</TT>である。
</DD>
</DL>
<BR>
<BR>

<A NAME="32073"></A>
<B>eps<SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img16.png"
 ALT="$ &gt;=$"></SPAN></B> <EM>num1 num2 [(tolerance *epsilon*)] </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>num1</EM>が多分<EM>num2</EM>よりも大きいときあるいは等しいときTを返す。すなわち、
<TT>num1<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="22" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img15.png"
 ALT="$ &gt;$"></SPAN>num2-tolerance</TT>である。
</DD>
</DL>
<BR>
<BR>

<P>
	<BR> 
<A NAME="32087"></A>
<BIG CLASS="XLARGE"><B>bounding-box </B></BIG> [クラス]  <PRE><TT>
  :super   <B>object</B> 
<BR>  :slots 		 (minpoint maxpoint) 
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD>xy-,yz-やzx-平面に平行な面を境界とする最小の四角柱を定義する。
<B>bounding-box</B>は、初期に与えられるベクトルの次元によって、
どんな次元でも使用することができる。
<B>bounding-box</B>は、surrounding-boxの名前で定義されていた。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32106"></A>
<B>:box</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この<B>bounding-box</B>のオブジェクト自身を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32117"></A>
<B>:volume</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この<B>bounding-box</B>の体積を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32128"></A>
<B>:grow</B> <EM>rate </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>bounding-box</B>のサイズを<EM>rate</EM>率で増加または減少させる。
<EM>rate</EM>が0.01のとき、1%拡大される。
</DD>
</DL>
<BR>
<BR>

<A NAME="32141"></A>
<B>:inner</B> <EM>point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>point</EM>がこの<B>bounding-box</B>内にあればTを返し、
そうでないときはNILを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32153"></A>
<B>:intersection</B> <EM>box2 &amp;optional tolerance </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>bounding-box</B>と<EM>box2</EM>との共通<TT>bounding-box</TT>を返す。
もし、<EM>torelance</EM>が与えられたならば、この<B>box</B>はその誤差で拡大される。
もし、共通部分がなければ、NILを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32168"></A>
<B>:union</B> <EM>box2 </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>bounding-box</B>と<EM>box2</EM>を結合した<TT>bounding-box</TT>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32181"></A>
<B>:intersectionp</B> <EM>box2 </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>bounding-box</B>と<EM>box2</EM>との間に共通領域があればTを返し、
そうでなければNILを返す。
このメソッドは、<B>:intersection</B>よりも速い。なぜなら、新しい
<B>bounding-box</B>のインスタンスを作らないためである。
</DD>
</DL>
<BR>
<BR>

<A NAME="32195"></A>
<B>:extreme-point</B> <EM>direction </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>bounding-box</B>の８つの頂点の中で、<EM>direction</EM>との内積が最大のものを
返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32207"></A>
<B>:corners</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>bounding-box</B>のすべての頂点のリストを返す。
もし、この<B>box</B>が2次元であれば、4点が返される。
同様に3次元の場合、8点が返される。
</DD>
</DL>
<BR>
<BR>

<A NAME="32219"></A>
<B>:below</B> <EM>box2 &amp;optional (direction #(0 0 1) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>bounding-box</B>が<EM>box2</EM>に対して<EM>direction</EM>の示すベクトル
の下の方向にあればTを返す。
この<B>boundign-box</B>が<EM>direction</EM>の方向に動かされるとき、
2つのboxに共通部分でできるかどうかをチェックするために使用される。
</DD>
</DL>
<BR>
<BR>

<A NAME="32234"></A>
<B>:body</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>bounding-box</B>によって内包される立方体を表現する
<B>body</B>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32246"></A>
<B>:init</B> <EM>vlist &amp;optional tolerance </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<TT>minpoint</TT>と<TT>maxpoint</TT>スロットを<EM>vlist</EM>から設定する。
もし、<EM>torelance</EM>が指定されたなら、この<B>bounding-box</B>は
その量で増大される。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32261"></A>
<B>make-bounding-box</B> <EM>points [tolerance] </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>points</EM>のリストの中から最小と最大の座標値を見つけ、
<TT>bounding-box</TT>のインスタンスを作る。
</DD>
</DL>
<BR>
<BR>

<A NAME="32273"></A>
<B>bounding-box-union</B> <EM>boxes [tolerance *contact-threshold*] </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>boxes</EM>の結合で表現されるbounding-boxのインスタンスを作る。
その結果は、<EM>tolerance</EM>によって拡張される。
</DD>
</DL>
<BR>
<BR>

<A NAME="32285"></A>
<B>bounding-box-intersection</B> <EM>boxes [tolerance *contact-threshold*] </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>boxes</EM>の共通領域を表現するbounding-boxのインスタンスを作る。
その結果は、<EM>tolerance</EM>によって拡張される。
</DD>
</DL>
<BR>
<BR>

             <P>

<H2><A NAME="SECTION03042000000000000000">
線とエッジ</A>
</H2>

<P>
頂点の順番やエッジの順番の向きは、<B>body</B>を外から見たときに反時計方向
に整列するように定義される。
<TT>pvertex</TT>や<TT>nvertex</TT>や<TT>pface</TT>や<TT>nface</TT>は、
<TT>pface</TT>が外から見たときエッジの左側に位置しているとき、
<TT>pvertex</TT>から<TT>nvertex</TT>に向かう方向にエッジを定義する。

<P>

 <BR>
<BR> <P>
	<BR> 
<A NAME="32298"></A>
<BIG CLASS="XLARGE"><B>line </B></BIG> [クラス]  <PRE><TT>
  :super   <B>propertied-object</B> 
<BR>  :slots 		 ((pvert :type floatvector)(nvert :type floatvector)) 
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD><TT>pvert</TT>と<TT>nvert</TT>の上を通る線分を定義する。
線分は、<EM>pvert</EM>から<EM>nvert</EM>に向かう方向を持つ。
<TT>t <SPAN CLASS="MATH"><IMG
 WIDTH="7" HEIGHT="9" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img86.png"
 ALT="$ \cdot$"></SPAN> pvert +(1-t)nvert</TT>
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32320"></A>
<B>:vertices</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> <TT>pvert</TT>と<TT>nvert</TT>のリストを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32332"></A>
<B>:point</B> <EM>p </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この線分の上で<EM>p</EM>パラメータで示される位置の3次元のベクトルを返す。
<TT>p <SPAN CLASS="MATH"><IMG
 WIDTH="7" HEIGHT="9" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img86.png"
 ALT="$ \cdot$"></SPAN> pvert + (1-p)nvert</TT>
</DD>
</DL>
<BR>
<BR>

<A NAME="32344"></A>
<B>:parameter</B> <EM>point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この線分の上の<EM>point</EM>に対するパラメータを計算する。
これは、<B>:point</B>メソッドの逆メソッドである。
</DD>
</DL>
<BR>
<BR>

<A NAME="32356"></A>
<B>:direction</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
<TT>pvert</TT>から<TT>nvert</TT>へ向かう正規化ベクトルを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32368"></A>
<B>:end-point</B> <EM>v </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この線分の他の端点を返す。すなわち、
もし<EM>v</EM>が<TT>pvert</TT>に等しいとき、<TT>nvert</TT>を返す。
もし<EM>v</EM>が<TT>nvert</TT>に等しいとき、<TT>pvert</TT>を返す。
それ以外のとき、NILを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32384"></A>
<B>:box</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この線分の<B>bounding-box</B>を作成し、返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32395"></A>
<B>:boxtest</B> <EM>box </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>box</EM>とこの線分の<B>bounding-box</B>の共通部分をチェックする。
</DD>
</DL>
<BR>
<BR>

<A NAME="32407"></A>
<B>:length</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この線分の長さを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32417"></A>
<B>:distance</B> <EM>point-or-line </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この線分と<EM>point-or-line</EM>の間の距離を返す。
もし点からこの線分におろした垂線の足が
<TT>pvert</TT>と<TT>nvert</TT>の間になければ、
最も近い端点までの距離を返す。
このメソッドを使うことにより、2つの線分の間の距離を計算することができるため、
2つの円柱の間の干渉をテストすることができる。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32430"></A>
<B>:foot</B> <EM>point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>point</EM>からこの線分へおろした垂線の足である点を示すパラメータ
を見つける。
</DD>
</DL>
<BR>
<BR>

<A NAME="32441"></A>
<B>:common-perpendicular</B> <EM>l </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この線分と<EM>l</EM>とに垂直な線分を見つけ、2つの3次元ベクトルのリスト
として返す。
2つの線分が平行で共通な垂線が一意に決定できないとき、<TT>:parallel</TT>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32453"></A>
<B>:project</B> <EM>plane </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>plane</EM>に<TT>pvert</TT>と<TT>nvert</TT>を投影した2つの点のリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32466"></A>
<B>:collinear-point</B> <EM>point &amp;optional (tolerance *coplanar-threshold*) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<B>collinear-p</B>を用いて<EM>torelance</EM>の誤差範囲内で<EM>point</EM>がこの線分と
一直線上にあるかどうかをチェックする。
もし、<EM>point</EM>がこの線分と一直線上にあるとき、その線分のその点に
対するパラメータを返す。そうでなければ、NILを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32480"></A>
<B>:on-line-point</B> <EM>point &amp;optional (tolerance *coplanar-threshold*) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>point</EM>がこの線分と一直線上にあり、<TT>pvert</TT>と<TT>nvert</TT>との間に
あるかどうかをチェックする。
</DD>
</DL>
<BR>
<BR>

<A NAME="32493"></A>
<B>:collinear-line</B> <EM>ln &amp;optional (tolerance *coplanar-threshold*) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>ln</EM>がこの線分と共通線上にあるとき、すなわち<EM>ln</EM>の両端がこの線分上に
あるときTを返し、そうでないときNILを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32505"></A>
<B>:coplanar</B> <EM>ln &amp;optional (tolerance *coplanar-threshold*) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>ln</EM>とこの線分が共通平面上にあるかどうかをチェックする。
この線分の両端と<EM>ln</EM>の1つの端点で平面が定義される。
もし、<EM>ln</EM>の他の端点がその平面上にあるとき、Tを返す。
そうでなければ、NILを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32518"></A>
<B>:intersection</B> <EM>ln </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>ln</EM>は、この線分と共通平面上にあるとする。
<B>:intersection</B>は、これら2つの線分の交点に対する2つのパラメータの
リストを返す。
パラメータは0から1までの実数である。これは、両端で区切られた
線分の内分点を示す。2つの線が平行であるときNILを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32530"></A>
<B>:intersect-line</B> <EM>ln </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>ln</EM>は、この線分と共通平面上にあるとする。
交点のパラメータが<TT>:parallel, :collinear</TT>や<TT>:intersect</TT>のような
シンボル情報と共に返される。
</DD>
</DL>
<BR>
<BR>

<P>
	<BR> 
<A NAME="32544"></A>
<BIG CLASS="XLARGE"><B>edge </B></BIG> [クラス]  <PRE><TT>
  :super   <B>line</B> 
<BR>  :slots 		 (pface nface 
<BR>(angle :type float) 
<BR>(flags :type integer)) 
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD>2つの面の間の交差線分として定義されるエッジを表現する。
<TT>pface</TT>と<TT>nface</TT>がスロットの中に定義されているが、
それらの解釈はこのエッジの方向によって相対的に決まる。
例えば、このエッジが<TT>pvert</TT>から<TT>nvert</TT>に向かっていると
考えたとき、<TT>pface</TT>が正しいpfaceを表現している。
そのため、<B>:pface</B>や<B>:nface</B>メソッドで適当な面を選択するためには、
pvertとnvertの解釈を与えなければならない。

</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32568"></A>
<B>make-line</B> <EM>point1 point2 </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>point1</EM>を<TT>pvert</TT>とし、<EM>point2</EM>を<TT>nvert</TT>とする
<B>line</B>のインスタンスを作る。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32583"></A>
<B>:pvertex</B> <EM>pf </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>pf</EM>をこのエッジの<TT>pface</TT>とみなした<TT>pvertex</TT>を返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32596"></A>
<B>:nvertex</B> <EM>pf </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>pf</EM>をこのエッジの<TT>pface</TT>とみなした<TT>nvertex</TT>を返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32609"></A>
<B>:body</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> このエッジを定義する<B>body</B>オブジェクトを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32620"></A>
<B>:pface</B> <EM>pv nv </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 仮想的に<EM>pv</EM>と<EM>nv</EM>をこのエッジの
pvertとnvertに解釈したときのpfaceを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32632"></A>
<B>:nface</B> <EM>pv nv </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 仮想的に<EM>pv</EM>と<EM>nv</EM>をこのエッジの
pvertとnvertに解釈したときのnfaceを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32644"></A>
<B>:binormal</B> <EM>aface </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
このエッジと<EM>aface</EM>の正規化ベクトルに垂直な方向ベクトルを見つける。
</DD>
</DL>
<BR>
<BR>

<A NAME="32655"></A>
<B>:angle</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
このエッジでつながった2つの面の間の角度を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32665"></A>
<B>:set-angle</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
このエッジでつながった2つの面の間の角度を計算し、
それを<TT>angle</TT>スロットに置く。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32676"></A>
<B>:invert</B> [メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="32687"></A>
<B>:set-face</B> <EM>pv nv f </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>f</EM>を<TT>pface</TT>とし、<EM>pv</EM>を<TT>pvertex</TT>とし、<EM>nv</EM>を
<TT>nvertex</TT>として設定する。
このメソッドは、このエッジの<TT>pface</TT>あるいは<TT>nface</TT>を変更することに
注意すること。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32705"></A>
<B>:contourp</B> <EM>viewpoint </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
もし、このエッジが輪郭エッジであれば、すなわち、このエッジの<TT>pface</TT>
あるいは<TT>nface</TT>のどちらかが<EM>viewpoint</EM>から見え、もう一方が
見えないならTを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32718"></A>
<B>:approximated-p</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
このエッジが円柱の側面のような曲面を表現するための近似エッジであるならば、
Tを返す。
近似エッジは部分直線で曲線を表現するのに必要である。

</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32728"></A>
<B>:set-approximated-flag</B> <EM>&amp;optional (threshold 0.7) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
Euslispでは、どんな曲面もたくさんの平面で近似される。
<TT>flags</TT>のLSBは、このエッジの両側の面が曲面であるかどうかを
示すために使用される。

<P>
もし、2つの面の間の角度が<EM>threshold</EM>より大きいなら、
<B>:set-approximated-flag</B>は、このフラグをTに設定する。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32741"></A>
<B>:init</B> <EM>&amp;key :pface :nface :pvertex :nvertex </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<P>
             <P>

<H2><A NAME="SECTION03043000000000000000">
平面と面</A>
</H2>

<P>
<B>plane</B>オブジェクトは、その平面の正規化ベクトルと座標原点から平面までの
距離で表現される。
2対の正規化ベクトルと距離が<B>plane</B>オブジェクトに記録される。
1つは、変換後の現状を表現し、もう1つが平面を定義したときの
正規化ベクトルと距離を表現する。

<P>

 <BR>
<BR> <P>
	<BR> 
<A NAME="32753"></A>
<BIG CLASS="XLARGE"><B>plane </B></BIG> [クラス]  <PRE><TT>
  :super   <B>propertied-object</B> 
<BR>  :slots 		 ((normal :type float-vector) 
<BR>(distance :float)) 
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD>平面方程式を定義する。平面は境界がなく、無限に広がっているものとする。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32770"></A>
<B>:normal</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この平面の正規化ベクトルを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32780"></A>
<B>:distance</B> <EM>point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この平面と<EM>point</EM>との間の距離を計算する。
</DD>
</DL>
<BR>
<BR>

<A NAME="32791"></A>
<B>:coplanar-point</B> <EM>point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
もし、<EM>point</EM>がこの平面の上に置かれているならTを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32802"></A>
<B>:coplanar-line</B> <EM>line </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
もし、<EM>line</EM>がこの平面の上に置かれているなら、Tを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32813"></A>
<B>:intersection</B> <EM>point1 point2 </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>point1</EM>と<EM>point2</EM>を端点とする線分とこの平面との交点
を計算する。その線分の上の交点に対するパラメータを返す。
もし、線分とこの平面が平行であるなら、<TT>:parallel</TT>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32826"></A>
<B>:intersection-edge</B> <EM>edge </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この平面と<EM>point1</EM>と<EM>point2</EM>で表現される線分あるいはエッジとの
交点のパラメータを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32838"></A>
<B>:foot</B> <EM>point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この平面上に<EM>point</EM>を直角に投影した位置の３次元ベクトルを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32849"></A>
<B>:init</B> <EM>normal point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>point</EM>を通り<EM>normal</EM>を面の正規化ベクトルとする平面を定義する。
<EM>normal</EM>は、正規化されていなければならない。<!-- MATH
 $|normal|=1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="jmanual-img88.png"
 ALT="$ \vert normal\vert=1$"></SPAN>
</DD>
</DL>
<BR>
<BR>

<P>
	<BR> 
<A NAME="32863"></A>
<BIG CLASS="XLARGE"><B>polygon </B></BIG> [クラス]  <PRE><TT>
  :super   <B>plane</B> 
<BR>  :slots 		 (convexp edges vertices 
<BR>(model-normal float-vector) 
<BR>(model-distance :float))
<BR>
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD><B>polygon</B>は、平面の上の輪で表現される。
<TT>convexp</TT>は、その輪が凸面であるかどうかを示す論理フラグである。
<TT>edges</TT>は、この輪の輪郭や頂点のリストである<TT>vertices</TT>で
形成されるエッジのリストである。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="32884"></A>
<B>:box</B> <EM>&amp;optional tolerance </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この多角形のための<B>bounding-box</B>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32895"></A>
<B>:boxtest</B> <EM>box2 &amp;optional tolerance </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この多角形のための<B>bounding-box</B>を作成し，
その<B>boundign-box</B>と<EM>box2</EM>との共通領域を返す。
もし，共通領域がなかった場合，NILを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32908"></A>
<B>:edges</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この多角形のエッジのリストを返す。
そのリストは，この平面の正規化ベクトルに沿ってその多角形を見たとき，
時計方向の順番になっている。
もし，正規化ベクトルをねじと考えると，そのエッジは
ねじを入れる方向に回転させる向きの順番になっている。
多角形または面が立体オブジェクトの面を表現するために使用されているとき，
その正規化ベクトルはその立体の外側に向かっている。
多角形をそのオブジェクトの外側から見たとき，エッジは
反時計方向の順番になっている。
</DD>
</DL>
<BR>
<BR>

<A NAME="32918"></A>
<B>:edge</B> <EM>n </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> エッジの<EM>n</EM>番目の要素を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32929"></A>
<B>:vertices</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この多角形の頂点をエッジと同じ順番にならべたものを返す。
最初の頂点は，そのリストの最後に重複してコピーされているため，
そのリストは実際の頂点の数より１だけ長くなっていることに注意すること。
これは，頂点のリストを用いてエッジへの変換を簡単にするためである。
</DD>
</DL>
<BR>
<BR>

<A NAME="32939"></A>
<B>:vertex</B> <EM>n </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 頂点の<EM>n</EM>番目の要素を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32950"></A>
<B>:insidep</B> <EM>point &amp;optional (tolerance *epsilon*) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この領域に対して相対的に置かれた<EM>point</EM>の位置にしたがって
<TT>:inside</TT>,<TT>:outside</TT>あるいは<TT>:border</TT>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32964"></A>
<B>:intersect-point-vector</B> <EM>point vnorm </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>point</EM>と正規化方向ベクトル<EM>vnorm</EM>によって定義される
擬似線分との交点を計算する。
</DD>
</DL>
<BR>
<BR>

<A NAME="32976"></A>
<B>:intersect-line</B> <EM>p1 p2 </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>p1</EM>と<EM>p2</EM>で指定される線分との交点を計算する。
その結果は、交点がなければNILを返し，交点があればその交点の位置の
パラメータのリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32988"></A>
<B>:intersect-edge</B> <EM>edge </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>edge</EM>で指定される線分との交点を計算する。
その結果は，交点がなければNILを返し、交点があれば
交点の位置のパラメータのリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="32999"></A>
<B>:intersect-face</B> <EM>aregion </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
もし，この領域が<EM>aregion</EM>と交差しているなら，Tを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33010"></A>
<B>:transform-normal</B> [メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33021"></A>
<B>:reset-normal</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この多角形の現在の<TT>vertices</TT>リストから面の正規化ベクトルを再計算する。
</DD>
</DL>
<BR>
<BR>

<A NAME="33032"></A>
<B>:invert</B> [メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33043"></A>
<B>:area</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この領域の面積を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33053"></A>
<B>:init</B> <EM>&amp;key :vertices :edges :normal :distance </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<P>
	<BR> 
<A NAME="33065"></A>
<BIG CLASS="XLARGE"><B>face </B></BIG> [クラス]  <PRE><TT>
  :super   <B>polygon</B> 
<BR>  :slots 		 (holes mbody primitive-face id) 
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD>穴を持った面を定義する。
<EM>mbody</EM>と<EM>type</EM>は、基本bodyとbody内の面の属性<TT>(:top, :bottom, :side)</TT>
を表現する。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33085"></A>
<B>:all-edges</B> [メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33096"></A>
<B>:all-vertices</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この面および内部ループ（穴）の輪郭のエッジあるいは頂点をすべて返す。
<B>:edges</B>と<B>:verticies</B>メソッドは，
輪郭を構成するエッジと頂点のみを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33108"></A>
<B>:insidep</B> <EM>point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>point</EM>がこの面の内部にあるかどうかを決定する。
もし<EM>point</EM>がこの面の外側の輪郭の中にあり，どれかの穴の
範囲内にあるならば，外側として分類される。
</DD>
</DL>
<BR>
<BR>

<A NAME="33120"></A>
<B>:area</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この面の面積を返す。
これは，外側のエッジで囲まれる面積から穴の面積を引いたものである。
</DD>
</DL>
<BR>
<BR>

<A NAME="33130"></A>
<B>:centroid</B> <EM>&amp;optional point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この面の重心を表現する実数と実数ベクトルのリストを返す。
もし，<EM>point</EM>が与えられないならば，最初の数はこの多角形の
面積を表わし，2番目のベクトルがこの多角形の重心の位置を示す。
もし，<EM>point</EM>が与えられたならば，この多角形を底面としその点を頂点
とするような多角錐を考え，その体積と重心のベクトルを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33142"></A>
<B>:invert</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この面の向きをひっくり返す。
正規化ベクトルが逆方向とされ，エッジループの順番も反転される。
</DD>
</DL>
<BR>
<BR>

<A NAME="33152"></A>
<B>:enter-hole</B> <EM>hole </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この面に穴<EM>hole</EM>を加える。
</DD>
</DL>
<BR>
<BR>

<A NAME="33163"></A>
<B>:primitive-body</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この面を定義する基本<B>body</B>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33174"></A>
<B>:id</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
<TT>(:bottom), (:top)</TT>や<TT>(:side seq-no.)</TT>の中の1つを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33186"></A>
<B>:face-id</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
基本<B>body</B>の型とこの面の型をリストで返す。
例えば，円柱の側面は
<TT>((:cylinder <EM>radius height segments</EM>) :side <EM>id</EM>)</TT>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33200"></A>
<B>:body-type</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この面を定義する基本<B>body</B>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33211"></A>
<B>:init</B> <EM>&amp;key :normal :distance :edges :vertices :holes </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<P>
	<BR> 
<A NAME="33223"></A>
<BIG CLASS="XLARGE"><B>hole </B></BIG> [クラス]  <PRE><TT>
  :super   <B>polygon</B> 
<BR>  :slots 		 (myface) 
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD>穴は，面の内部ループを表現する多角形である。<B>face</B>のオブジェクトは、
自分の<TT>holes</TT>スロット
の中に<B>hole</B>のリストを持っている。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33243"></A>
<B>:face</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この<B>hole</B>を含む面を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33254"></A>
<B>:enter-face</B> <EM>face </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>hole</B>を囲んでいる面<EM>face</EM>へリンクを作る。
このメソッドは、<B>face</B>クラスの<TT>:enter-hole</TT>メソッドと共に
使用されるものである。
</DD>
</DL>
<BR>
<BR>

<A NAME="33268"></A>
<B>:init</B> <EM>&amp;key :normal :distance :edges :vertices :face </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<P>

<H2><A NAME="SECTION03044000000000000000">
立体(body)</A>
</H2>

<P>
	<BR> 
<A NAME="33280"></A>
<BIG CLASS="XLARGE"><B>body </B></BIG> [クラス]  <PRE><TT>
  :super   <B>cascaded-coords</B> 
<BR>  :slots 		 (faces edges vertices model-vertices box convexp evertedp csg) 
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD>３次元形状を定義する。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33297"></A>
<B>:magnify</B> <EM>rate </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>のサイズを<EM>rate</EM>で変更する。拡大は，<TT>csg</TT>リストの中に
記録される。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33310"></A>
<B>:translate-vertices</B> <EM>vector </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
モデルの頂点を相対移動する。<EM>vector</EM>はローカル座標系で与えられなければならない。
変換は<TT>csg</TT>リストに記録される。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33322"></A>
<B>:rotate-vertices</B> <EM>angle axis </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
モデルの頂点を<EM>axis</EM>軸回りに<EM>angle</EM>ラジアン回転させる。
回転は<TT>csg</TT>リストに記録される。
</DD>
</DL>
<BR>
<BR>

<A NAME="33335"></A>
<B>:reset-model-vertices</B> [メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33346"></A>
<B>:newcoords</B> <EM>rot &amp;optional pos </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
座標系を<EM>rot</EM>や<EM>pos</EM>を用いて変更する。
<EM>pos</EM>が省略された時は<EM>newrot</EM>にはcoordinatesのインスタンスを与える。
</DD>
</DL>
<BR>
<BR>

<A NAME="33360"></A>
<B>:vertices</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この<B>body</B>のすべての頂点のリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33371"></A>
<B>:edges</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この<B>body</B>のすべてのエッジのリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33382"></A>
<B>:faces</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>を構成するすべての面のリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33393"></A>
<B>:box</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> この<B>body</B>の<B>bounding-box</B>を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33405"></A>
<B>:Euler</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>のオイラー数を計算する。これは，
<TT>faces+vertices<SPAN CLASS="MATH"><IMG
 WIDTH="408" HEIGHT="874" BORDER="0"
 SRC="jmanual-img3.png"
 ALT="\begin{figure}\small
\begin{verbatim}object
cons
queue
propertied-object
s...
...h-table
surrounding-box
stereo-viewing\end{verbatim}
\normalsize\end{figure}"></SPAN>edges<SPAN CLASS="MATH"><IMG
 WIDTH="408" HEIGHT="874" BORDER="0"
 SRC="jmanual-img3.png"
 ALT="\begin{figure}\small
\begin{verbatim}object
cons
queue
propertied-object
s...
...h-table
surrounding-box
stereo-viewing\end{verbatim}
\normalsize\end{figure}"></SPAN>2<SPAN CLASS="MATH"><IMG
 WIDTH="408" HEIGHT="874" BORDER="0"
 SRC="jmanual-img3.png"
 ALT="\begin{figure}\small
\begin{verbatim}object
cons
queue
propertied-object
s...
...h-table
surrounding-box
stereo-viewing\end{verbatim}
\normalsize\end{figure}"></SPAN>holes</TT>である。
これは，<TT><SPAN CLASS="MATH"><IMG
 WIDTH="408" HEIGHT="874" BORDER="0"
 SRC="jmanual-img3.png"
 ALT="\begin{figure}\small
\begin{verbatim}object
cons
queue
propertied-object
s...
...h-table
surrounding-box
stereo-viewing\end{verbatim}
\normalsize\end{figure}"></SPAN>2rings</TT>と等しくなるべきである。
</DD>
</DL>
<BR>
<BR>

<A NAME="33418"></A>
<B>:perimeter</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
すべてのエッジの長さの合計を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33428"></A>
<B>:volume</B> <EM>&amp;optional (reference-point #f(0 0 0)) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>の体積を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33439"></A>
<B>:centroid</B> <EM>&amp;optional (point #f(0 0 0) </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>が均質な立体と仮定し，重心の位置を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33450"></A>
<B>:possibly-interfering-faces</B> <EM>box </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33461"></A>
<B>:common-box</B> <EM>body </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>と他の<EM>body</EM>の共通な最小の<B>box</B>を返す。
もし，2つの<B>body</B>が干渉しているならば，その交差部分は
この共通<B>box</B>の中に存在するはずである。
</DD>
</DL>
<BR>
<BR>

<A NAME="33476"></A>
<B>:insidep</B> <EM>point </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
もし，<EM>point</EM>がこの<B>body</B>に属するなら，<TT>:inside</TT>を返す。
もし，<EM>point</EM>がこの<B>body</B>の表面上にある場合，<TT>:border</TT>を返す。
そうでなければ，<TT>:outside</TT>を返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33493"></A>
<B>:intersect-face</B> <EM>face </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
もし，この<B>body</B>の面と<EM>face</EM>の間に干渉がある場合，Tを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33505"></A>
<B>:intersectp</B> <EM>body </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>と他の<EM>body</EM>との間の交差部分を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33517"></A>
<B>:evert</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> すべての面とエッジの方向を反転させる。
そのため，この<B>body</B>の内部は外部になる。
</DD>
</DL>
<BR>
<BR>

<A NAME="33528"></A>
<B>:faces-intersect-with-point-vector</B> <EM>point direction </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>point</EM>から<EM>direction</EM>の方向に伸びるベクトルと交差する面をすべて集める。
</DD>
</DL>
<BR>
<BR>

<A NAME="33540"></A>
<B>:distance</B> <EM>target </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>target</EM>は，実数ベクトルあるいは平面オブジェクトである。
<B>:distance</B>メソッドは，<EM>target</EM>から最も近い面を見つけ，
その面と距離のリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33553"></A>
<B>:csg</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
<B>body</B>が構築された履歴である<TT>csg</TT>スロットを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33565"></A>
<B>:primitive-body</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>を構築する基本<B>body</B>のリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33577"></A>
<B>:primitive-body-p</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> もし，この<B>body</B>が<A HREF="#primitive-body-creation">14.5</A>
節で示される関数の内の1つから作られた基本<B>body</B>であるなら，Tを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33590"></A>
<B>:creation-form</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
この<B>body</B>を作るためのLisp表現を返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33601"></A>
<B>:body-type</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
もし，この<B>body</B>が基本<B>body</B>あるいはこの<B>body</B>の表現が複雑（に構成された）
<B>body</B>なら，作成パラメータのリストを返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33615"></A>
<B>:primitive-groups</B> [メソッド]

<DL COMPACT>
<DT> 
<DD> 
2つの要素をもつリストを返す。
最初の要素は，この<B>body</B>を構成するために追加(body+)された基本<B>body</B>
のリストである。次の要素は，差し引かれた基本<B>body</B>のリストである。
</DD>
</DL>
<BR>
<BR>

<A NAME="33628"></A>
<B>:get-face</B> <EM>body &amp;optional face id </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>body</EM>は，この<B>body</B>を構成している<B>body</B>のインスタンスであり，
基本<B>body</B>型の1つである。例えば，<TT>:cube, :prism, :cone, :solid-of-resolution</TT>などか
あるいはNILである。
もし，<EM>face</EM>も<EM>id</EM>も与えられないならば，<EM>body</EM>に一致する面をすべて返す。
もし，<EM>face</EM>が与えられたなら，その上にフィルターが実行される。
<EM>face</EM>は，<TT>:top</TT>,<TT>:bottom</TT>と<TT>:side</TT>の内の1つでなければならない。
<TT>(send abody :get-face :cylinder :top)</TT>は，<TT>abody</TT>を構成する円柱の上面すべてを返す。
もし，<EM>face</EM>が<TT>:side</TT>なら，<EM>id</EM>で番号付けされた面を取り出すことができる。
<TT>(send abody nil :side 2)</TT>は，<EM>id</EM>が0から始まるため，<TT>abody</TT>を構成する
<B>body</B>の側面から３番目の面をすべて返す。
</DD>
</DL>
<BR>
<BR>

<A NAME="33660"></A>
<B>:init</B> <EM>&amp;key :faces :edges :vertices </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> 
<EM>:faces</EM>よりこの<B>body</B>を初期化する。
<EM>:faces</EM>は，必要な引き数である。
<EM>:faces</EM>,<EM>:edges</EM>と<EM>:vertices</EM>は完全な立体モデルを定義するために
矛盾のない関係を持っていなければならないので，矛盾した引き数でこのメソッドを
呼び出すことは，意味の無いことである。
<B>body</B>を作るために，<A HREF="#primitive-body-creation">14.5</A>節で書いている基本<B>body</B>の作成関数と
<A HREF="#BodyComposition">14.6</A>節の<B>body</B>合成関数を使用する。
</DD>
</DL>
<BR>
<BR>

<A NAME="33681"></A>
<B>:constraint</B> <EM>b </EM>[メソッド]

<DL COMPACT>
<DT> 
<DD> この<B>body</B>が<EM>b</EM>に接触しているとき，
この<B>body</B>の拘束を返す。このメソッドの詳細な説明は<A HREF="#Contact">14.8</A>節を参照すること。
</DD>
</DL>
<BR>
<BR>

<P>

<H2><A NAME="SECTION03045000000000000000"></A><A NAME="primitive-body-creation"></A>
<BR>
基本bodyの作成関数
</H2>

<P>

 <BR>
<BR> <P>

<A NAME="33695"></A>
<B>make-plane</B> <EM>&amp;key :normal :point :distance </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>point</EM>を通り，<EM>normal</EM>の方向を向いた<B>plane</B>オブジェクトを作る。
<EM>point</EM>を与える代わり<EM>distance</EM>を指定することもできる。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33710"></A>
<B>*xy-plane*</B> [変数]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33721"></A>
<B>*yz-plane*</B> [変数]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33732"></A>
<B>*zx-plane*</B> [変数]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<P>

<DIV ALIGN="CENTER"><A NAME="31465"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 10:</STRONG>
基本body</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="578" HEIGHT="850" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img89.png"
 ALT="\includegraphics[height=19cm]{fig/fig1.ps}">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<A NAME="33743"></A>
<B>make-cube</B> <EM>xsize ysize zsize &amp;key :name :color </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
x,y,z軸の方向に大きさが<EM>xsize</EM>,<EM>ysize</EM>,<EM>zsize</EM>である，直方体を作る。
この直方体の原点は<B>body</B>の中心に置かれる。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33757"></A>
<B>make-prism</B> <EM>bottom-points sweep-vector &amp;key :name :color </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>sweep-vector</EM>に沿った<EM>bottom-points</EM>により定義される
形状を積み上げることにより角柱を作る。
もし、<EM>sweep-vector</EM>が実数ベクトルでなく数字であれば、<SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="11" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img90.png"
 ALT="$ z$"></SPAN>方向の
角柱の高さとして扱われる。
<EM>bottom-points</EM>は，この<B>body</B>の底面を定義する順番になっていなければならない。
例えば，
 <TT>(make-prism '(#f(1 1 0) #f(1 -1 0) #f(-1 -1 0) #f(-1 1 0)) 2.0)</TT>
は，高さ2.0の直方体を作る。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33773"></A>
<B>make-cylinder</B> <EM>radius height &amp;key (:segments 12) :name :color </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
半径<EM>radius</EM>と高さ<EM>height</EM>で指定される円柱を作る。
底面は，xy-平面に定義され，座標系の原点は底面の中心に置かれる。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33785"></A>
<B>make-cone</B> <EM>top bottom &amp;key (:segments 16) :color :name </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
頂点が<EM>top</EM>で底面が<EM>bottom</EM>である角錐を作る。
<EM>top</EM>は，3次元ベクトルである。
<EM>bottom</EM>は，底面の頂点のリストあるいは半径である。
もし，頂点のリストなら，順番を慎重にしなさい。
&nbsp; (make-cone #f(0 0 10) (list #f(10 0 0) #f(0 10 0) #f(-10 0 0)
#f(0 -10 0)))&nbsp; は，正方形の底面を持つ四角錐を作る。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33799"></A>
<B>make-solid-of-revolution</B> <EM>points &amp;key (:segments 16) :name :color </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>points</EM>は，z軸まわりの時計方向に回転される。
もし、<EM>points</EM>のリストの2つの端点がz軸上に置かれてないならば，
曲面を作る。したがって，
<TT>(make-solid-of-revolution '(#f(0 0 1) #f(1 0 0)))</TT>
は、円錐を作り、
<TT>(make-solid-of-revolution '(#f(1 0 1) #f(1 0 0)))</TT>
は、円柱を作る。
<EM>points</EM>は、順番が重要であり、<SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="11" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img90.png"
 ALT="$ z$"></SPAN>軸の高い方から低い方へ
整列しておくことが望まれる。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33814"></A>
<B>make-torus</B> <EM>points &amp;key (:segments 16) :name :color </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
ドーナッツのようなtorus形状を作る。
<EM>points</EM>は，断面上の頂点のリストである。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33825"></A>
<B>make-icosahedron</B> <EM>&amp;optional (radius 1.0) </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
正20面体を作る。それぞれの面は正三角形である。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33835"></A>
<B>make-dodecahedron</B> <EM>&amp;optional (radius 1.0) </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
正12面体を作る。それぞれの面は，正五角形である。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33845"></A>
<B>make-gdome</B> <EM>abody </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>abody</EM>の三角面を4つの面に小分けすることにより
測地ドームを新しく作る。
<EM>abody</EM>は，最初正20面体とすべきである。
それから，<B>make-gdome</B>の結果を再帰的に<B>make-gdome</B>に与えることができる。
それぞれの呼び出しで，測地ドームの面の数は，4倍に増加する。すなわち，
20, 80, 320, 1280, 5120などになる。
</DD>
</DL>
<BR>
<BR>

<P><PRE>
(setq g0 (make-icosahedron 1.0))        ; 20 facets
(setq g1 (make-gdome g0))               ; 80 facets
(setq g2 (make-gdome g1))               ; 320 facets
...
</PRE>

<P>

<A NAME="33859"></A>
<B>grahamhull</B> <EM>vertices &amp;optional (normal #f(0 0 1)) </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
Grahamのアルゴリズムを用いて，2次元上で凸状の覆いを計算する。
<B>quickhull</B>よりも遅い。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33870"></A>
<B>quickhull</B> <EM>vertices &amp;optional (normal #f(0 0 1)) </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
2分探索法を用いて2次元上で凸状の覆いを計算する。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33880"></A>
<B>convex-hull-3d</B> <EM>vertices </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
gift-wrapping法を用いて3次元上で凸面の覆いを計算する。
</DD>
</DL>
<BR>
<BR>

<A NAME="33890"></A>
<B>make-body-from-vertices</B> <EM>vertices-list </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
矛盾しない順番になっている面のループを定義する頂点のリストから<B>body</B>を返す。
</DD>
</DL>
<BR>
<BR>

<P>
             <P>

<H2><A NAME="SECTION03046000000000000000"></A><A NAME="BodyComposition"></A>
<BR>
bodyの合成関数
</H2>

<P>

 <BR>
<BR> <P>

<A NAME="33901"></A>
<B>face+</B> <EM>face1 face2 </EM>[関数]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33912"></A>
<B>face*</B> <EM>face1 face2 </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>face1</EM>と<EM>face2</EM>は，3次元上で共通平面上にある。
<B>face+</B>は，これらの面の結合を構築し，面のオブジェクトとして返す。
もし，交差領域がないなら，元の2つの面が返される。
<B>face*</B>は，これらの面の交差領域を返す。もし，交差領域がなければ，NILを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33926"></A>
<B>cut-body</B> <EM>body cutting-plane </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>body</EM>を<EM>cutting-plane</EM>で切断し，その切断面に作られる面のリストを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33938"></A>
<B>body+</B> <EM>body1 body2 &amp;rest more-bodies </EM>[関数]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33949"></A>
<B>body-</B> <EM>body1 body2 </EM>[関数]

<DL COMPACT>
<DT> 
<DD>  
</DD>
</DL>
<BR>
<BR>

<A NAME="33960"></A>
<B>body*</B> <EM>body1 body2 </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
2つあるいはそれ以上の<B>body</B>の和，差あるいは積を計算する。
それぞれのbodyは，<B>body+, body-, body*</B>の処理を行う前に
コピーされ，元のbodyは変更されない。
その結果のbodyの新しい座標系の位置・姿勢は，ワールド座標系のものと一致している。
もし，しきい値パラメータ<TT>*coplanar-threshold*</TT>,<TT>*contact-threshold*</TT>,<TT>*parallel-threshold*</TT>
を正確に設定するなら，2つの<B>body</B>が面同士で接触している場合でも
これらの関数は正しく働くであろう。
しかしながら，もし<B>body</B>の頂点が他の<B>body</B>の頂点あるいは面に接触している場合，
どの処理も失敗する。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33978"></A>
<B>body/</B> <EM>body plane </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<B>make-plane</B>で作られた<B>plane</B>クラスのインスタンスである<EM>plane</EM>で
<EM>body</EM>を切断する。新しく作られた<B>body</B>が返される。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="33993"></A>
<B>body-interference</B> <EM>&amp;rest bodies </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
<EM>bodies</EM>の中で1対1の組み合わせにおける干渉をチェックし，
交差している2つの<B>body</B>のリストを返す。
</DD>
</DL>
<BR>
<BR>

<P>
             <P>

<H2><A NAME="SECTION03047000000000000000">
座標軸</A>
</H2>
<B>coordinates-axes</B>クラスは，画面上に表示可能な3次元座標軸を定義する。
それぞれの軸とz軸の頂点の矢印は，<B>line</B>オブジェクトで定義される。
このクラスは，<B>cascaded-coords</B>を継承しているので，
このクラスのオブジェクトは，<B>body</B>のような他の<B>cascaded-coords</B>を元とする
オブジェクトに付けることができる。
このオブジェクトは，<B>body</B>の座標軸あるいは他の座標の相対座標系を見るために
使用される。

<P>

 <BR>
<BR> <BR> 
<A NAME="34006"></A>
<BIG CLASS="XLARGE"><B>coordinates-axes </B></BIG> [クラス]  <PRE><TT>
  :super   <B>cascaded-coords</B> 
<BR>  :slots 		 (size model-points points lines) 
</TT></PRE>
<BR>
<BR>

<DL COMPACT>
<DT> 
<DD>表示可能な3次元座標軸を定義する。
</DD>
</DL>
<BR>
<BR>
             <P>


<H2><A NAME="SECTION03048000000000000000"></A><A NAME="Contact"></A>
<BR>
立体の接触状態解析
</H2>

<P>
この節のメソッドおよび関数は、次のファイルに記述されている。
<B>contact/model2const.l, contact/inequalities.l, contact/drawconst.l</B>

<P>

 <BR>
<BR> <P>

<A NAME="36633"></A>
<B>constrained-motion</B> <EM>c </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 拘束<EM>c</EM>を満たしている
動作のリストを返す。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="36644"></A>
<B>constrained-force</B> <EM>m </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 拘束されている<B>body</B>から
拘束している<B>body</B>に加わる力を返す。<EM>m</EM>は、<B>constrained-motion</B>
から返される動作のリストである。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="36658"></A>
<B>draw-constraint</B> <EM>c </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 拘束<EM>c</EM>を描く。
</DD>
</DL>
<BR>
<BR>

<P>

<A NAME="36669"></A>
<B>draw-motion</B> <EM>m a b </EM>[関数]

<DL COMPACT>
<DT> 
<DD> <EM>a</EM>が<EM>b</EM>に接触しているときに
取り得る動作を描く。リターンキーを押すことにより描画を始める。
</DD>
</DL>
<BR>
<BR>
Example
<BR><PRE>
;;
;;      peg in a hole with 6 contact points
;;
(in-package "GEOMETRY")
(load "view")
(load "../model2const.l" :package "GEOMETRY")
(load "../inequalities.l" :package "GEOMETRY")
(load "../drawconst.l" :package "GEOMETRY")

(setq x (make-prism '(#f(50 50 0) #f(50 -50 0) #f(-50 -50 0) #f(-50 50 0))
                    #f(0 0 200)))
(setq x1 (copy-object x))
(send x1 :translate #f(0 0 -100))
(send x1 :worldcoords)
(setq a1 (make-prism '(#f(100 100 -150) #f(100 -100 -150)
                       #f(-100 -100 -150) #f(-100 100 -150))
                     #f(0 0 150)))
(setq ana (body- a1 x1))
(send x :translate #f(0 -18.30127 -18.30127))
(send x :rotate -0.523599 :x)
(send x :worldcoords)

(setq c (list (send x :constraint ana)))
(setq m (constrained-motion c))
(setq f (constrained-force m))

(hidd x ana)
(draw-constraint c)
(draw-motion m)
</PRE>

拘束の例を次の図で示す。図の小さな矢印は，ペグに対する拘束を示す。

<BR>
<DIV ALIGN="CENTER"><A NAME="fig:peg-in-hole"></A><A NAME="36614"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 11:</STRONG>
Constraints for a peg in a hole.</CAPTION>
<TR><TD><IMG
 WIDTH="244" HEIGHT="328" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img91.png"
 ALT="\includegraphics[width=7.9cm]{fig/fig-peg-in-hole1.ps}">
<IMG
 WIDTH="242" HEIGHT="331" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img92.png"
 ALT="\includegraphics[width=7.9cm]{fig/fig-peg-in-hole2.ps}">
<BR><IMG
 WIDTH="238" HEIGHT="316" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img93.png"
 ALT="\includegraphics[width=7.9cm]{fig/fig-peg-in-hole3.ps}">
<IMG
 WIDTH="238" HEIGHT="275" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img94.png"
 ALT="\includegraphics[width=7.9cm]{fig/fig-peg-in-hole4.ps}"></TD></TR>
</TABLE>
</DIV>

ペグを穴に入れる作業において取り得る動作の例を次の図で示す。
この例は，上記のプログラムと一致している。

<DIV ALIGN="CENTER"><A NAME="fig:peg-in-a-hole"></A><A NAME="36624"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 12:</STRONG>
Possible motions of a peg in a hole</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="251" HEIGHT="331" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img95.png"
 ALT="\includegraphics[width=7.9cm]{fig/fig-peg-naname-m1.ps}">
<IMG
 WIDTH="243" HEIGHT="341" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img96.png"
 ALT="\includegraphics[width=7.9cm]{fig/fig-peg-naname-m2.ps}">
<BR><IMG
 WIDTH="243" HEIGHT="338" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img97.png"
 ALT="\includegraphics[width=7.9cm]{fig/fig-peg-naname-m3.ps}">
<IMG
 WIDTH="249" HEIGHT="331" ALIGN="BOTTOM" BORDER="0"
 SRC="jmanual-img98.png"
 ALT="\includegraphics[width=7.9cm]{fig/fig-peg-naname-m4.ps}">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>


<H2><A NAME="SECTION03049000000000000000">
多角形のVoronoi Diagram</A>
</H2>

<P>
<EM>著者: Philippe PIGNON, 電総研ゲスト研究者</EM>

<P>
このプログラムは，Common Lispで書かれている。
 "A sweepline algorithm for Voronoi diagrams", Proceedings of
the 2nd Annual ACM symposium on computational geometry, 1986, 313-322.を
手法として用い、
多角形の場合への応用を行った。これは，サンプルプログラム付きの簡単な説明である。
このプログラムは，ETLのEuslisp環境で書かれているため，
画像への出力もサポートしている。
どのCommon Lisp上でも使用することはできるが，
<TT>utilities.l</TT>で与えられている画像への関数を自分のディスプレイ環境へ
合うように書き換える必要がある。この節の最後にその関数を示す。

<P>
<DL>
<DT><STRONG>目的:</STRONG></DT>
<DD>多角形の集合のvoronoi diagramの計算を行う。
語彙を理解するために上記の文献を読んで、使用してください。
ここでは、このプログラムに対する説明をしません。

<P>
</DD>
<DT><STRONG>入力:</STRONG></DT>
<DD>多角形のリストと囲むための枠は，次のように定義する。
<PRE>
DATA= (
       (x11 y11 x12 y12 x13 y13 ...) first polygon,
                                     counterclocwise enumeration of vertices
       (x21 y21 x22 y22 x23 y23 ...) second polygon
               ... 
       (xn1 yn1 xn2 yn2 xn3 yn3 ...) nth polygon
	     
       (xf1 yf1 xf2 yf2 xf3 yf3 xf4 yf4) enclosing frame
      )
</PRE>
囲む枠は，<B>DATA</B>内のどの位置にも配置することができる。また，
内部と外部が矛盾しないように時計方向の順番でなければならない。
多角形は交差の無い簡単な図形でなければならない。
一直線あるいは平坦なエッジは受け付けない。
独立した点あるいは線分も受け付けない。

<P>
</DD>
<DT><STRONG>出力:</STRONG></DT>
<DD><B>*diagram*</B>:2重に接続されたエッジリストのリスト
(utilities.lファイルを参照)を返す。それぞれのエッジは，symbolであり，次に示す
ようなfieldを含むproperty-listを持っている。
<PRE>
(start &lt;pointer to a vertex&gt;)
       (end &lt;pointer to a vertex&gt;)
       (pred &lt;pointer to an edge&gt;)
       (succ &lt;pointer to an edge&gt;)
       (left &lt;pointer to a site&gt;)
       (right &lt;pointer to a site&gt;)
       (type &lt;:endpoint or :point-point or :segment-segment or :point-segment&gt;)
       (outflag &lt;t or nil&gt;)
</PRE>
<EM>vertex</EM>は，symbolで"<TT>pos</TT>"fieldを含むproperty-listを持つ。
このfieldは，cons<EM>(x,y)</EM>を含み，<EM>vertex</EM>の平面座標を示す。
<EM>pred</EM>と<EM>succ</EM>のfieldは，decl形式にしたがって反時計方向の
前者と後者を与える(ShamosとPreparataの,
Computational Geometry: An introduction, 1985, pp 15-17を参照)。
<EM>site</EM>もsymbolであり，関連した情報を含むproperty-listを持つ。
<EM>site</EM>は，元の入力データを記述しており，多角形の頂点であるpoint
あるいは多角形のエッジであるsegmentを持つ。

<P>
<EM>type</EM>は，2等分線の中点であり，それを分割する<EM>site</EM>の型より
決定される。
規約により，外側はstart-endエッジの右側である。
voronoi diagramは，2等分線の内部と同様に外側を計算する。
必要とするoutflagを保つためにoutflagをソートする。

<P>
</DD>
<DT><STRONG>サンプル:</STRONG></DT>
<DD>サンプルプログラムを実行するためには，以下のようなステップを実施してください。

<OL>
<LI>自分の環境に以下のプログラムをコピーする。
<BR><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">utilities.l</TD>
<TD ALIGN="LEFT">幾何学ユーティリティ関数とeusxの画像出力関数</TD>
</TR>
<TR><TD ALIGN="LEFT">polygonalvoronoi.l</TD>
<TD ALIGN="LEFT">プログラム本体</TD>
</TR>
<TR><TD ALIGN="LEFT">testdata.l</TD>
<TD ALIGN="LEFT">上記の書式によるデモデータ</TD>
</TR>
</TABLE>
</LI>
<LI>もし，Euslispを使用しないなら，命令にしたがって<TT>utilities.l</TT>を書き換え，
"compatibility package"を修正する。。
</LI>
<LI>以下の3つのファイルをコンパイルしてロードするか、あるいはそのままロードする。
<BR><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">utilities.l</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">polygonalvoronoi.l</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">testdata.l</TD>
<TD ALIGN="LEFT">上記の書式によるデモデータを含んでいる。</TD>
</TR>
</TABLE>
</LI>
<LI>(pv demoworld)でデモデータ上でプログラムが実行される。
グローバル変数<B>*diagram*</B>には，voronoi diagramの2等分線が含まれている。
</LI>
</OL>
</DD>
</DL>

<P>
eusx(Xwindowインターフェースを持つEuslisp)のもとでは，以下の命令でdiagramの結果を画面上に表示することができる。
<PRE>
       (make-display)          ;;Initializes the *display* window object
       (dps demoworld *thick*) ;; Shows original data in thick lines
       (dbs *diagram*)         ;; Shows the result
</PRE>

<P>

 <BR>
<BR> <A NAME="36789"></A>
<B>pv</B> <EM>data </EM>[関数]

<DL COMPACT>
<DT> 
<DD> 
上記の書式で書かれた<EM>data</EM>から多角形のvoronoi diagramを計算する。
</DD>
</DL>
<BR>
<BR>

             <P>


<DIV CLASS="navigation"><HR>
<BR>
<B> Next:</B> <A NAME="tex2html793"
  HREF="jmanual-node18.html">視界とグラフィックス</A>
<B>Up:</B> <A NAME="tex2html787"
  HREF="jmanual-node13.html">EusLisp 拡張</A>
<B> Previous:</B> <A NAME="tex2html781"
  HREF="jmanual-node16.html">幾何学関数</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
Travis CI User
2017-03-07
</ADDRESS>
</BODY>
</HTML>

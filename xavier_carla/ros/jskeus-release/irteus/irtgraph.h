static pointer CLO846();
static pointer CLO855();
static pointer CLO874();
static pointer CLO912();
static pointer CLO913();
static pointer CLO951();
static pointer CLO961();
static pointer FLET962();
static pointer FLET996();
static pointer CLO1042();
static pointer UWP1004();
static pointer CLO1076();
static pointer CLO1081();
static pointer (*ftab[21])();

#define QUOTE_STRINGS_SIZE 272
static char *quote_strings[QUOTE_STRINGS_SIZE]={
    ":name",
    "remove",
    "remove-if",
    ":to",
    ":add-arc",
    "super",
    ":prin1",
    "\"~A->~A~A\"",
    "\"\"",
    "node",
    ":successors",
    ":key",
    ":test",
    "equal",
    "find",
    "set-difference",
    ":unlink",
    "send-all",
    ":remove-all-arcs",
    "arc",
    ":init",
    ":from",
    ":remove-arc",
    "make-matrix",
    ":arc-list",
    "position",
    "<",
    "#(:both)",
    ":add-arc-from-to",
    ":both",
    "#(:both)",
    "costed-arc",
    ":cost",
    "#(:both)",
    "#(:both)",
    "*standard-output*",
    "\"output\"",
    ":get",
    ":draw-both-arc",
    ":draw-arc-label",
    ":draw-merged-result",
    "\"digraph ~A {~%\"",
    "\"   \"",
    "\"~A [label = \\\"~A\\\"];~%\"",
    "make-hash-table",
    ":state",
    "\"color = red\"",
    "sethash",
    "gethash",
    "\"color = red\"",
    "\"label = \\\"~A\\\"\"",
    "cdr",
    "member",
    "\"dir = both\"",
    ":no-option",
    "\"}~%\"",
    "\"output\"",
    ":direction",
    ":output",
    "open",
    ":write-to-dot-stream",
    "\"pdf\"",
    "\"~A.dot\"",
    ":write-to-dot",
    "\"dot ~A -T~A -o ~A\"",
    "\"~A.~A\"",
    "\".pdf\"",
    "string-right-trim",
    "\".pdf\"",
    "substringp",
    "\"pdf\"",
    ":write-to-file",
    ":put",
    ":write",
    ":merge",
    "string",
    "assoc",
    "maphash",
    "\"   \"",
    "\"~A -> ~A\"",
    "\";~%\"",
    "\"[\"",
    "\", \"",
    "\"~A\"",
    "\"];~%\"",
    ":neighbors",
    "#(:name)",
    "#(:cost :parent :action)",
    ":parent",
    ":path",
    "send",
    "solver-node",
    ":action",
    ":path-cost",
    "#(:verbose)",
    ":start-state",
    ":node",
    ":goal-state",
    ":solve",
    ":verbose",
    ":add-to-open-list",
    "#(:verbose)",
    ":solve-init",
    ":null-open-list?",
    ":pop-from-open-list",
    ":debug",
    ":goal-test",
    ":find-node-in-close-list",
    ":add-list-to-open-list",
    ":expand",
    "\"open-list is nil... -- ~A --~%\"",
    "warn",
    "\"search was missed!! -- ~A --~%\"",
    ":clear-open-list",
    ":add-object-to-open-list",
    "\"you have to override :clear-open-list method~%\"",
    "\"you have to override :add-list-to-open-list method~%\"",
    "\"you have to override :add-object-to-open-list method~%\"",
    "#(:debug)",
    "\"you have to override :pop-from-open-list method~%\"",
    "#(:debug)",
    "#(:debug)",
    "#(:debug)",
    ":priority-value",
    ":fn",
    "\"<~A> v -> ~A~%\"",
    "\"<~A> v -> ~A~%\"",
    "\":pop-from-open-list result...~%\"",
    "\"min-value -> ~A~%\"",
    "\"min-x -> ~A~%\"",
    ":count",
    "delete",
    "#(:debug)",
    "\"g(n) -> ~A -- F(N) --~%\"",
    ":gn",
    "\"h(n) -> ~A -- F(N) --~%\"",
    ":hn",
    "\"You have to override :hn~%\"",
    ":global",
    ":super",
    "propertied-object",
    ":slots",
    "(arc-list)",
    ":metaclass",
    ":element-type",
    ":size",
    ":documentation",
    "make-class",
    "\"(self class n)\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class a)\"",
    "\"(self class a)\"",
    "\"(self class)\"",
    "\"(self class n)\"",
    "(from to)",
    "\"(self class from_ to_)\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class &optional (strm t) &rest msgs)\"",
    "directed-graph",
    "(nodes)",
    "\"(self class)\"",
    "\"(self class node &rest args)\"",
    "\"(self class name)\"",
    ":nodes",
    "\"(self class &optional arg)\"",
    ":add-node",
    "\"(self class n)\"",
    ":remove-node",
    "\"(self class n)\"",
    ":clear-nodes",
    "\"(self class)\"",
    "\"(self class from to)\"",
    "\"(self class arc)\"",
    ":adjacency-matrix",
    "\"(self class)\"",
    ":adjacency-list",
    "\"(self class)\"",
    "(cost)",
    "\"(self class from to c)\"",
    "\"(self class)\"",
    "costed-graph",
    "nil",
    "\"(self class from to cost &key (both nil))\"",
    "\"(self class from to cost &key (both nil))\"",
    "\"(self class from arc to)\"",
    "graph",
    "(start-state goal-state)",
    "\"(self class gs)\"",
    "\"(self class from arc to)\"",
    "\"(self class &optional arg)\"",
    "\"(self class &optional arg)\"",
    "\"(self class from to &key (both nil))\"",
    "\"(self class from to &key (both nil))\"",
    "\"write graph structure to stream as dot(graphviz) style\nArgs:\n  strm: stream class for output\n  result-path: list of solver-node, it's result of (send solver :solve graph)\n  title: title of graph\n\"",
    "\"write graph structure to dot(graphviz) file\nArgs:\n  fname: filename for output\n  result-path: list of solver-node, it's result of (send solver :solve graph)\n  title: title of graph\n\"",
    "\"write graph structure to various type of file\nArgs:\n  basename: basename for output (output filename is 'basename.type')\n  result-path: list of solver-node, it's result of (send solver :solve graph)\n  title: title of graph\n  type: type of output\n\"",
    ":write-to-pdf",
    "\"write graph structure to pdf\nArgs:\n  fname: filename for output\n  result-path: list of solver-node, it's result of (send solver :solve graph)\n  title: title of graph\n\"",
    ":original-draw-mode",
    "\"change draw-mode to original mode\"",
    ":current-draw-mode",
    "\"change draw-mode to latest mode\"",
    "\"change draw-mode, if true is set, draw bidirectional arc as two arcs\"",
    "\"change draw-mode, if true is set, draw label(name) of arcs\"",
    "\"change draw-mode, if true is set, draw result arc as red. if not, draw red arc independently\"",
    ":add-neighbor",
    "\"(self class n &optional a)\"",
    "\"(self class &optional args)\"",
    "arced-node",
    "\"(self class &key name)\"",
    ":find-action",
    "\"(self class n)\"",
    ":neighbor-action-alist",
    "\"(self class)\"",
    "(state cost parent action memorized-path)",
    "\"(self class st &key ((:cost c) 0) ((:parent p) nil) ((:action a) nil))\"",
    "\"(self class &optional (prev nil))\"",
    "\"(self class prblm &rest args)\"",
    "\"(self class &optional arg)\"",
    "\"(self class &optional arg)\"",
    "\"(self class &optional arg)\"",
    "\"(self class &optional arg)\"",
    "solver",
    "\"(self class)\"",
    "\"(self class prblm)\"",
    ":solve-by-name",
    "\"(self class prblm s g &key (verbose nil))\"",
    "graph-search-solver",
    "(open-list close-list)",
    "\"(self class prblm)\"",
    "\"(self class n)\"",
    "\"(self class prblm &key (verbose nil))\"",
    "\"(self class obj/list)\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class lst)\"",
    "\"(self class lst)\"",
    "\"(self class &key (debug))\"",
    ":open-list",
    "\"(self class &optional arg)\"",
    ":close-list",
    "\"(self class &optional arg)\"",
    "breadth-first-graph-search-solver",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class lst)\"",
    "\"(self class obj)\"",
    "\"(self class &key (debug))\"",
    "depth-first-graph-search-solver",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class lst)\"",
    "\"(self class obj)\"",
    "\"(self class &key (debug))\"",
    "best-first-graph-search-solver",
    "(aproblem)",
    "\"(self class p)\"",
    "\"(self class)\"",
    "\"(self class lst)\"",
    "\"(self class obj)\"",
    "\"(self class &key (debug nil))\"",
    "\"(self class n p)\"",
    "a*-graph-search-solver",
    "\"(self class p)\"",
    "\"(self class n p &key (debug nil))\"",
    "\"(self class n p)\"",
    "\"(self class n p)\"",
    ":irtgraph",
    "\"$Id$\"",
    "provide",
  };

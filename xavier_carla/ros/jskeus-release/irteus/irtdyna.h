static pointer FLET3058();
static pointer CLO3075();
static pointer CLO3137();
static pointer CLO3404();
static pointer CLO3425();
static pointer CLO3426();
static pointer CLO3431();
static pointer CLO3436();
static pointer FLET3439();
static pointer CLO3464();
static pointer CLO3467();
static pointer CLO3468();
static pointer CLO3485();
static pointer CLO3502();
static pointer CLO3523();
static pointer FLET3549();
static pointer CLO3572();
static pointer CLO3573();
static pointer CLO3578();
static pointer CLO3579();
static pointer CLO3863();
static pointer CLO3873();
static pointer CLO3878();
static pointer CLO4036();
static pointer CLO3881();
static pointer CLO3886();
static pointer CLO3894();
static pointer CLO3901();
static pointer CLO3902();
static pointer CLO3903();
static pointer CLO3910();
static pointer CLO3913();
static pointer CLO3914();
static pointer CLO3922();
static pointer CLO3953();
static pointer CLO3957();
static pointer CLO3961();
static pointer CLO3962();
static pointer CLO3989();
static pointer CLO4010();
static pointer CLO4013();
static pointer CLO4016();
static pointer CLO4017();
static pointer CLO4018();
static pointer CLO4049();
static pointer (*ftab[45])();

#define QUOTE_STRINGS_SIZE 551
static char *quote_strings[QUOTE_STRINGS_SIZE]={
    "\"subclass's respoinsibility (send ~s :calc-inertia-matrix)~%\"",
    "warn",
    ":rotate-vector",
    "normalize-vector",
    "scale-matrix",
    ":worldpos",
    "user::calc-dif-with-axis",
    "#f(1.0 0.0 0.0)",
    "#f(0.0 1.0 0.0)",
    "#f(0.0 0.0 1.0)",
    "#f(1.0 0.0 0.0)",
    "#f(0.0 1.0 0.0)",
    "#f(0.0 0.0 1.0)",
    "#f(1.0 0.0 0.0)",
    "#f(0.0 1.0 0.0)",
    "#f(0.0 0.0 1.0)",
    "#f(1.0 0.0 0.0)",
    "#f(0.0 1.0 0.0)",
    "#f(0.0 0.0 1.0)",
    "#(:len)",
    ":weight",
    "#(:tmp-va :tmp-vb :len)",
    "eps=",
    "#(:tmp-ma :tmp-mb :tmp-mc :tmp-md :tmp-va :len)",
    "make-matrix",
    ":worldrot",
    ":inertia-tensor",
    "user::m+",
    "#(:update :tmp-va :tmp-vb :tmp-ma :tmp-mb :tmp-mc :tmp-md :additional-weights :additional-centroids :additional-inertias :self-centroid)",
    "send-all",
    ":centroid",
    ":append-weight-no-update",
    ":len",
    ":append-centroid-no-update",
    ":tmp-va",
    ":tmp-vb",
    ":append-inertia-no-update",
    ":tmp-ma",
    ":tmp-mb",
    ":tmp-mc",
    ":tmp-md",
    ":inverse-transform-vector",
    "#(:debug-view :tmp-va :tmp-vb :tmp-ma :tmp-mb :tmp-mc)",
    "float-vector",
    ":propagate-mass-properties",
    ":debug-view",
    ":put",
    ":m-til",
    ":append-mass-properties",
    ":get",
    ":i-til",
    ":c-til",
    ":additional-weights",
    ":additional-centroids",
    ":additional-inertias",
    ":self-centroid",
    ":update",
    "\";; joint = ~A ;; m-til = ~A[g], c-til = ~A[mm]~%\"",
    ":name",
    "#(:rotation-axis :translation-axis :inertia-matrix :axis-for-angular :tmp-v0 :tmp-v1 :tmp-v2 :tmp-va :tmp-vb :tmp-vc :tmp-vd :tmp-ma)",
    "user::axis",
    ":x",
    ":-x",
    ":y",
    ":-y",
    ":z",
    ":-z",
    ":parent-link",
    ":copy-worldcoords",
    ":transform",
    "user::default-coords",
    ":calc-inertia-matrix",
    "user::outer-product-matrix",
    "#(:tmp-va :tmp-vb :tmp-ma :tmp-mb :tmp-mc)",
    ":links",
    "user::all-child-links",
    "#(:link-list :rotation-axis :translation-axis :axis-dim :inertia-matrix :update-mass-properties :axis-for-angular :tmp-v0 :tmp-v1 :tmp-v2 :tmp-va :tmp-vb :tmp-vc :tmp-vd :tmp-ma :tmp-mb :tmp-mc)",
    ":child-link",
    ":calc-target-axis-dimension",
    ":calc-target-joint-dimension",
    ":update-mass-properties",
    ":joint",
    "send",
    ":calc-inertia-matrix-column",
    ":inertia-matrix",
    ":axis-for-angular",
    ":translation-axis",
    ":rotation-axis",
    ":joint-dof",
    "#(:link-list :rotation-axis :translation-axis :axis-dim :inertia-matrix :update-mass-properties)",
    ":calc-inertia-matrix-from-link-list",
    ":link-list",
    "array-dimensions",
    "#(:cog-gain :translation-axis :target-centroid-pos :centroid-offset-func :update-mass-properties)",
    ":calc-inverse-jacobian",
    ":calc-cog-jacobian-from-link-list",
    ":calc-vel-for-cog",
    ":centroid-offset-func",
    ":ik-target-error",
    "assoc",
    "#(:centroid-offset-func :update-mass-properties)",
    ":difference-cog-position",
    ":add-draw-on-param",
    "#(:centroid-offset-func :translation-axis :add-draw-on-param :update-mass-properties)",
    "functionp",
    ":ik-draw-on-params",
    ":color",
    "#f(0.0 0.0 1.0)",
    ":size",
    "#f(0.0 1.0 0.0)",
    "#(:centroid-offset-func :translation-axis :update-mass-properties)",
    "abs",
    "\"subclass's respoinsibility (send ~s :calc-spacial-velocity-jacobian)~%\"",
    "\"subclass's respoinsibility (send ~s :calc-angular-velocity-jacobian)~%\"",
    "\"subclass's respoinsibility (send ~s :calc-spacial-acceleration-jacobian)~%\"",
    "\"subclass's respoinsibility (send ~s :calc-angular-acceleration-jacobian)~%\"",
    ":angular-velocity",
    ":spacial-velocity",
    "#(:debug-view :tmp-va)",
    "\";; forward-all-kinematics link = ~A~%\"",
    ":parent",
    "user::bodyset-link",
    "#f(1.0 0.0 0.0)",
    "#f(0.0 1.0 0.0)",
    "#f(0.0 0.0 1.0)",
    ":xx",
    "#f(1.0 0.0 0.0)",
    ":yy",
    "#f(0.0 1.0 0.0)",
    ":zz",
    "#f(0.0 0.0 1.0)",
    "#f(-1.0 0.0 0.0)",
    "#f(0.0 -1.0 0.0)",
    "#f(0.0 0.0 -1.0)",
    ":angular-velocity-jacobian",
    ":calc-spacial-velocity-jacobian",
    ":spacial-velocity-jacobian",
    ":calc-angular-velocity-jacobian",
    ":joint-velocity",
    ":calc-spacial-acceleration-jacobian",
    ":spacial-acceleration",
    ":joint-acceleration",
    ":calc-angular-acceleration-jacobian",
    ":angular-acceleration",
    ":forward-all-kinematics",
    "#(:debug-view :tmp-va :tmp-vb :tmp-vc :tmp-ma :tmp-mb :tmp-mc :tmp-md)",
    "\";; inverse-dynamics link = ~A~%\"",
    "*g-vec*",
    ":inverse-dynamics",
    ":tmp-vc",
    ":force",
    ":moment",
    ":joint-torque",
    "user::calc-target-joint-dimension",
    "1",
    ":max-joint-torque",
    "#(:torque)",
    ":torque-vector",
    ":max-torque-vector",
    "#(:debug-view :calc-statics-p :dt :av :root-coords :force-list :moment-list :target-coords :calc-torque-buffer-args)",
    ":angle-vector",
    ":calc-torque-buffer-args",
    "\";; ERROR : list length differ in :calc-torque : force-list ~A moment-list ~A target-coords ~A~%\"",
    ":calc-torque-without-ext-wrench",
    ":calc-statics-p",
    ":av",
    ":root-coords",
    ":dt",
    "#(:debug-view :calc-statics-p :dt :av :root-coords :calc-torque-buffer-args)",
    ":calc-torque-from-vel-acc",
    ":calc-root-coords-vel-acc-from-pos",
    ":calc-av-vel-acc-from-pos",
    ":jvv",
    ":joint-velocity-vector",
    ":jav",
    ":joint-acceleration-vector",
    ":root-spacial-velocity",
    ":root-angular-velocity",
    ":root-spacial-acceleration",
    ":root-angular-acceleration",
    "#(:debug-view :jvv :jav :root-spacial-velocity :root-angular-velocity :root-spacial-acceleration :root-angular-acceleration :calc-torque-buffer-args)",
    ":analysis-level",
    ":coords",
    ":prev-root-coords",
    "unit-matrix",
    "user::matrix-exponent",
    "user::m-",
    "inverse-matrix",
    ":prev-root-v",
    ":prev-root-w",
    ":prev-av",
    ":angle-to-speed",
    ":prev-jvv",
    "#(:force-list :moment-list :target-coords :jacobi)",
    ":calc-jacobian-from-link-list",
    ":move-target",
    ":transform-coords",
    ":initial-element",
    "make-list",
    "concatenate",
    ":calc-union-link-list",
    "position",
    "#(:pzmpz :dt :update :debug-view :calc-torque-buffer-args)",
    ":calc-torque",
    ":zmp",
    ":zmp-moment",
    "#(:fz-thre :return-all-values)",
    ":inverse-rotate-vector",
    ":cop",
    ":transform-vector",
    ":fz",
    "#(:total-wrench :weight)",
    "fill",
    ":calc-grasp-matrix",
    "#(:flush :width :size :color :warning-color :torque-threshold :torque-vector :joint-list)",
    ":joint-list",
    "cons",
    ":viewsurface",
    ":flush",
    "#(:preview-controller-class :cog-method :delay)",
    "user::preview-controller",
    ":move-base-pos",
    "user::preview-control-cart-table-cog-trajectory-generator",
    ":init",
    ":delay",
    ":initialize-queue-p",
    ":preview-controller-class",
    ":calc-zmp",
    ":finishedp",
    ":update-xk",
    ":current-additional-data",
    ":move-centroid-on-foot",
    ":both",
    "(:lleg :rleg)",
    ":centroid-thre",
    ":target-centroid-pos",
    ":refcog",
    "(:rleg :lleg)",
    ":translate",
    ":world",
    "(:rleg :lleg)",
    ":newcoords",
    "user::objects",
    ":ext-force",
    ":ext-moment",
    "acos",
    "make-coords",
    "#f(1.0 0.0 0.0)",
    "#f(0.0 1.0 0.0)",
    "#f(0.0 0.0 1.0)",
    "#f(-1.0 0.0 0.0)",
    "#f(0.0 -1.0 0.0)",
    "#f(0.0 0.0 -1.0)",
    ":line-width",
    ":draw-circle",
    ":pos",
    ":rot",
    ":radius",
    ":arrow",
    ":arc",
    "deg2rad",
    ":move-coords",
    ":end-coords",
    ":inverse-kinematics",
    ":thre",
    ":rthre",
    "*viewer*",
    ":draw-objects",
    ":draw-on",
    "#f(1.0 0.0 0.0)",
    "#f(1.0 0.0 0.0)",
    "x::window-main-one",
    "unix:usleep",
    ":time",
    ":output-zmp",
    ":input-zmp",
    ":output-cog",
    ":input-cog",
    "cadddr",
    "array-dimension",
    "*epsilon*",
    "eps-v=",
    "\";; ERROR in (reccati (:solve)) : Counld not convergence ~A~%\"",
    "#(:q :r :delay :a :b :c :state-dim :output-dim :input-dim :init-xk :init-uk :initialize-queue-p)",
    "super",
    ":solve",
    ":calc-f",
    ":calc-u",
    ":last-reference-output-vector",
    ":calc-xk",
    ":current-reference-output-vector",
    ":current-state-vector",
    ":current-output-vector",
    "matrix-column",
    "#(:q :r :delay :a :b :c :init-xk :init-uk :state-dim :initialize-queue-p :q-mat)",
    ":a",
    ":b",
    ":c",
    ":state-dim",
    ":q",
    ":r",
    ":init-xk",
    ":init-uk",
    ":output-dim",
    ":input-dim",
    "#(:q :r :delay :init-xk :a :b :c :initialize-queue-p :preview-controller-class)",
    "user::extended-preview-controller",
    ":current-refzmp",
    ":cart-zmp",
    "user::c",
    "(user::footstep-node-list user::support-leg-list user::support-leg-coords-list user::swing-leg-dst-coords-list user::swing-leg-src-coords user::refzmp-cur-list user::step-height-list)",
    "defmethod",
    "user::gait-generator",
    "\":append-~A\"",
    "read-from-string",
    "user::_args",
    "setq",
    "append",
    "list",
    "remove-if",
    ":get-counter-footstep-limbs",
    ":get-footstep-limbs",
    "v+",
    ":get-limbs-zmp-list",
    ":initial-value",
    "reduce",
    "#(:default-step-height :default-double-support-ratio :delay :all-limbs :default-zmp-offsets :q :r :thre :rthre :start-with-double-support :end-with-double-support)",
    "(:rleg :lleg)",
    ":append-support-leg-list",
    ":append-support-leg-coords-list",
    ":append-swing-leg-dst-coords-list",
    ":append-refzmp-cur-list",
    ":get-limbs-zmp",
    ":append-step-height-list",
    ":make-gait-parameter",
    "last",
    ":get-swing-limbs",
    ":worldcoords",
    "expt",
    "ratio",
    "#(:type :step-height)",
    ":shuffling",
    "midcoords",
    ":cycloid",
    ":cycloid-midcoords",
    ":rot-ratio",
    "midpoint",
    ":calc-hoffarbib-pos-vel-acc",
    ":calc-current-refzmp",
    ":cog-z",
    "#(:type :solve-angle-vector :solve-angle-vector-args :debug)",
    ":solve-av-by-move-centroid-on-foot",
    ":calc-one-tick-gait-parameter",
    ":solve-angle-vector",
    ":solve-angle-vector-args",
    ":update-current-gait-parameter",
    ":finalize-gait-parameter",
    "#(:solve-angle-vector :solve-angle-vector-args)",
    "find-method",
    "\";; in :solve-angle-vector, invalid function or method~%!\"",
    "#(:cog-gain :stop :additional-nspace-list)",
    ":fix-limbs-target-coords",
    ":cog-gain",
    ":stop",
    ":additional-nspace-list",
    "#(:top-ratio)",
    "matrix",
    "#(:top-ratio :rot-ratio)",
    ":cycloid-midpoint",
    ":top-ratio",
    ":l/r",
    "remove-if-not",
    ":calc-current-swing-leg-coords",
    ":calc-ratio-from-double-support-ratio",
    ":type",
    ":step-height",
    ":support",
    ":swing",
    "(:rleg :lleg)",
    "(:rleg :lleg)",
    "(:rleg :lleg)",
    "2",
    "#f(1.0 0.0 0.0)",
    "4",
    "#f(0.0 0.0 1.0)",
    "#f(1.0 0.0 0.0)",
    "asin",
    "\"USER\"",
    "\"USER\"",
    "*package*",
    "\"no such package\"",
    ":irtgeo",
    "require",
    ":irtmodel",
    "user::joint",
    "\"(self class &rest args)\"",
    "user::calc-inertia-matrix-rotational",
    "\"(mat row column paxis m-til c-til i-til axis-for-angular child-link world-default-coords translation-axis rotation-axis tmp-v0 tmp-v1 tmp-v2 tmp-va tmp-vb tmp-vc tmp-vd tmp-m)\"",
    "user::calc-inertia-matrix-linear",
    "\"(mat row column paxis m-til c-til i-til axis-for-angular child-link world-default-coords translation-axis rotation-axis tmp-v0 tmp-v1 tmp-v2 tmp-va tmp-vb tmp-vc tmp-vd tmp-m)\"",
    "user::rotational-joint",
    "\"(self class mat row column paxis m-til c-til i-til axis-for-angular world-default-coords translation-axis rotation-axis tmp-v0 tmp-v1 tmp-v2 tmp-va tmp-vb tmp-vc tmp-vd tmp-m)\"",
    "user::linear-joint",
    "\"(self class mat row column paxis m-til c-til i-til axis-for-angular world-default-coords translation-axis rotation-axis tmp-v0 tmp-v1 tmp-v2 tmp-va tmp-vb tmp-vc tmp-vd tmp-m)\"",
    "user::omniwheel-joint",
    "\"(self class mat row column paxis m-til c-til i-til axis-for-angular world-default-coords translation-axis rotation-axis tmp-v0 tmp-v1 tmp-v2 tmp-va tmp-vb tmp-vc tmp-vd tmp-m)\"",
    "user::sphere-joint",
    "\"(self class mat row column paxis m-til c-til i-til axis-for-angular world-default-coords translation-axis rotation-axis tmp-v0 tmp-v1 tmp-v2 tmp-va tmp-vb tmp-vc tmp-vd tmp-m)\"",
    "user::6dof-joint",
    "\"(self class mat row column paxis m-til c-til i-til axis-for-angular world-default-coords translation-axis rotation-axis tmp-v0 tmp-v1 tmp-v2 tmp-va tmp-vb tmp-vc tmp-vd tmp-m)\"",
    "\"(self class additional-weights &key (len (length additional-weights)))\"",
    "\"(self class additional-weights additional-centroids self-centroid new-weight &key (tmp-va (float-vector 0 0 0)) (tmp-vb (float-vector 0 0 0)) (len (length additional-weights)))\"",
    "\"(self class additional-weights additional-centroids additional-inertias self-centroid new-centroid &key (tmp-ma (make-matrix 3 3)) (tmp-mb (make-matrix 3 3)) (tmp-mc (make-matrix 3 3)) (tmp-md (make-matrix 3 3)) (tmp-va (float-vector 0 0 0)) (len (length additional-weights)))\"",
    "\"(self class additional-links &key (update t) (tmp-va (float-vector 0 0 0)) (tmp-vb (float-vector 0 0 0)) (tmp-ma (make-matrix 3 3)) (tmp-mb (make-matrix 3 3)) (tmp-mc (make-matrix 3 3)) (tmp-md (make-matrix 3 3)) (additional-weights (send-all additional-links :weight)) (additional-centroids (send-all additional-links :centroid)) (additional-inertias (mapcar #'(lambda (x) (m* (m* (send x :worldrot) (send x :inertia-tensor) tmp-ma) (transpose (send x :worldrot) tmp-mb))) additional-links)) (self-centroid (send self :centroid)))\"",
    "\"(self class &key (debug-view nil) (tmp-va (instantiate float-vector 3)) (tmp-vb (instantiate float-vector 3)) (tmp-ma (make-matrix 3 3)) (tmp-mb (make-matrix 3 3)) (tmp-mc (make-matrix 3 3)))\"",
    "\"(self class column &rest args &key (rotation-axis nil) (translation-axis t) ((:inertia-matrix im)) (axis-for-angular (float-vector 0 0 0)) (tmp-v0 (instantiate float-vector 0)) (tmp-v1 (instantiate float-vector 1)) (tmp-v2 (instantiate float-vector 2)) (tmp-va (instantiate float-vector 3)) (tmp-vb (instantiate float-vector 3)) (tmp-vc (instantiate float-vector 3)) (tmp-vd (instantiate float-vector 3)) (tmp-ma (make-matrix 3 3)) &allow-other-keys)\"",
    "user::cascaded-link",
    "\"(self class &key (tmp-va (instantiate float-vector 3)) (tmp-vb (instantiate float-vector 3)) (tmp-ma (make-matrix 3 3)) (tmp-mb (make-matrix 3 3)) (tmp-mc (make-matrix 3 3)))\"",
    "\"(self class &rest args &key (link-list (send-all joint-list :child-link)) (rotation-axis nil) (translation-axis t) (axis-dim (send self :calc-target-axis-dimension rotation-axis translation-axis)) (inertia-matrix (make-matrix axis-dim (send self :calc-target-joint-dimension link-list))) (update-mass-properties t) (axis-for-angular) (tmp-v0 (instantiate float-vector 0)) (tmp-v1 (instantiate float-vector 1)) (tmp-v2 (instantiate float-vector 2)) (tmp-va (instantiate float-vector 3)) (tmp-vb (instantiate float-vector 3)) (tmp-vc (instantiate float-vector 3)) (tmp-vd (instantiate float-vector 3)) (tmp-ma (make-matrix 3 3)) (tmp-mb (make-matrix 3 3)) (tmp-mc (make-matrix 3 3)) &allow-other-keys)\"",
    "\"(self class &rest args &key (link-list (send-all joint-list :child-link)) (rotation-axis nil) (translation-axis t) (axis-dim (send self :calc-target-axis-dimension rotation-axis translation-axis)) (inertia-matrix (make-matrix axis-dim (send self :calc-target-joint-dimension link-list))) (update-mass-properties t) &allow-other-keys)\"",
    ":cog-jacobian-balance-nspace",
    "\"(self class link-list &rest args &key (cog-gain 1.0) (translation-axis :z) (target-centroid-pos) (centroid-offset-func) (update-mass-properties t) &allow-other-keys)\"",
    "\"(self class cog-gain translation-axis target-centroid-pos &key (centroid-offset-func) (update-mass-properties t))\"",
    "\"(self class target-centroid-pos &key (centroid-offset-func) (translation-axis :z) (add-draw-on-param) (update-mass-properties t))\"",
    ":cog-convergence-check",
    "\"(self class centroid-thre target-centroid-pos &key (centroid-offset-func) (translation-axis :z) (update-mass-properties t))\"",
    "\"(self class &rest args)\"",
    "\"(self class &rest args)\"",
    "\"(self class &rest args)\"",
    "\"(self class &rest args)\"",
    "\"(self class ax tmp-va tmp-vb)\"",
    "\"(self class ax tmp-va)\"",
    "\"(self class svj avj tmp-va tmp-vb)\"",
    "\"(self class avj tmp-va)\"",
    "\"(self class ax tmp-va tmp-vb)\"",
    "\"(self class ax tmp-va)\"",
    "\"(self class svj avj tmp-va tmp-vb)\"",
    "\"(self class avj tmp-va)\"",
    ":reset-dynamics",
    "\"(self class)\"",
    "\"(self class &optional aa)\"",
    "\"(self class &optional aa)\"",
    "\"(self class &optional aa)\"",
    "\"(self class &optional sa)\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class &optional f)\"",
    "\"(self class &optional m)\"",
    "\"(self class &key (debug-view nil) (tmp-va (float-vector 0 0 0)))\"",
    "\"(self class &key (debug-view nil) (tmp-va (float-vector 0 0 0)) (tmp-vb (float-vector 0 0 0)) (tmp-vc (float-vector 0 0 0)) (tmp-ma (make-matrix 3 3)) (tmp-mb (make-matrix 3 3)) (tmp-mc (make-matrix 3 3)) (tmp-md (make-matrix 3 3)))\"",
    "\"(self class)\"",
    ":torque-ratio-vector",
    "\"(self class &rest args &key (torque (send* self :torque-vector args)))\"",
    "\"(self class)\"",
    "\"(self class &key (debug-view nil) (calc-statics-p t) (dt 0.005) (av (send self :angle-vector)) (root-coords (send (car (send self :links)) :copy-worldcoords)) (force-list) (moment-list) (target-coords) (calc-torque-buffer-args (send self :calc-torque-buffer-args)))\"",
    "\"(self class &key (debug-view nil) (calc-statics-p t) (dt 0.005) (av (send self :angle-vector)) (root-coords (send (car (send self :links)) :copy-worldcoords)) (calc-torque-buffer-args (send self :calc-torque-buffer-args)))\"",
    "\"(self class &key (debug-view nil) (jvv (instantiate float-vector (length joint-list))) (jav (instantiate float-vector (length joint-list))) (root-spacial-velocity (float-vector 0 0 0)) (root-angular-velocity (float-vector 0 0 0)) (root-spacial-acceleration (float-vector 0 0 0)) (root-angular-acceleration (float-vector 0 0 0)) (calc-torque-buffer-args (send self :calc-torque-buffer-args)))\"",
    "\"(self class dt root-coords)\"",
    "\"(self class dt av)\"",
    ":calc-torque-from-ext-wrenches",
    "\"(self class &key (force-list) (moment-list) (target-coords) ((:jacobi tmp-jacobi)))\"",
    "\"Calculate Zero Moment Point based on Inverse Dynamics.\n     The output is expressed by the world coordinates, \n     and depends on historical robot states of the past 3 steps. Step is incremented when this method is called.\n     After solving Inverse Dynamics, ZMP is calculated from total root-link force and moment.\n     necessary arguments -> av and root-coords.\n     If update is t, call inverse dynamics, otherwise, just return zmp from total root-link force and moment.\n     dt [s] is time step used only when update is t.\n     pZMPz is ZMP height [mm].\n     After this method, (send robot :get :zmp) is ZMP and (send robot :get :zmp-moment) is moment around ZMP.\"",
    ":calc-cop-from-force-moment",
    "\"(self class force moment sensor-coords cop-coords &key (fz-thre 1) (return-all-values))\"",
    ":wrench-vector->wrench-list",
    "\"(self class wrench-vector)\"",
    ":wrench-list->wrench-vector",
    "\"(self class wrench-list)\"",
    ":calc-contact-wrenches-from-total-wrench",
    "\"(self class target-pos-list &key (total-wrench) (weight (fill (instantiate float-vector (* 6 (length target-pos-list))) 1)))\"",
    ":draw-torque",
    "\"(self class vwer &key flush (width 2) (size 100) (color (float-vector 1 0.3 0)) (warning-color (float-vector 1 0 0)) (torque-threshold nil) (torque-vector (send self :torque-vector)) ((:joint-list jlist) (send self :joint-list)))\"",
    "\"Calculate total robot weight [g].\n    If update-mass-properties argument is t, propagate total mass prop calculation for all links and returns total robot weight.\n    Otherwise, do not calculate total weight, just returns pre-computed total robot weight.\"",
    "\"Calculate total robot centroid (Center Of Gravity, COG) [mm] in euslisp world coordinates.\n    If update-mass-properties argument is t, propagate total mass prop calculation for all links and returns total robot centroid.\n    Otherwise, do not calculate total mass prop, just returns pre-computed total robot centroid.\"",
    "\"Calculate total robot inertia tensor [g $mm^2$] around total robot centroid in euslisp world coordinates.\n    If update-mass-properties argument is t, propagate total mass prop calculation for all links and returns total robot inertia tensor.\n    Otherwise, do not calculate total mass prop, just returns pre-computed total robot inertia tensor.\"",
    ":preview-control-dynamics-filter",
    "\"(self class dt avs &key (preview-controller-class preview-controller) (cog-method :move-base-pos) (delay 0.8))\"",
    "user::riccati-equation",
    ":global",
    ":super",
    "propertied-object",
    ":slots",
    "(user::a user::b user::c user::p user::q user::r user::k user::a-bkt user::r+btpb-1)",
    ":metaclass",
    ":element-type",
    ":documentation",
    "make-class",
    "\"(self class aa bb cc qq rr)\"",
    "\"(self class)\"",
    "(user::xk user::uk user::delay user::f1-n user::y1-n user::queue-index user::initialize-queue-p user::additional-data-queue user::finishedp user::initialized-p user::output-dim user::input-dim)",
    "\"Initialize preview-controller.\n     Q is weighting of output error and R is weighting of input.\n     dt is sampling time [s].\n     delay is preview time [s].\n     init-xk is initial state value.\n     A, B, C are state eq matrices.\n     If initialize-queue-p is t, fill all queue by the first input at the begenning, otherwise, do not fill queue at the first.\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"Update xk by inputting reference output.\n    Return value : nil (initializing) => return values (middle) => nil (finished)\n    If p is nil, automatically the last value in queue is used as input and preview controller starts finishing.\"",
    "\"Finished or not.\"",
    "\"Last value of reference output queue vector (y_k+N_ref).\n    Last value is latest future value.\"",
    "\"First value of reference output queue vector (y_k_ref).\n    First value is oldest future value and it can be used as current reference value.\"",
    "\"Current state value (xk).\"",
    "\"Current output value (yk).\"",
    "\"Current additional data value.\n    First value of additional-data-queue.\"",
    ":pass-preview-controller",
    "\"Get preview controller results from reference-output-vector-list and returns list.\"",
    "(user::orga user::orgb user::orgc user::xk*)",
    "\"Initialize preview-controller in extended system (error system).\n     Q is weighting of output error and R is weighting of input.\n     dt is sampling time [s].\n     delay is preview time [s].\n     init-xk is initial state value.\n     A, B, C are state eq matrices for original system and slot variables A,B,C are used for error system matrices.\n     If initialize-queue-p is t, fill all queue by the first input at the begenning, otherwise, do not fill queue at the first.\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"Current additional data value.\n    First value of additional-data-queue.\"",
    "(user::pcs user::cog-z user::zmp-z)",
    "\"COG (xy) trajectory generator using preview-control convert reference ZMP from reference COG.\n     dt -> sampling time[s], _zc is height of COG [mm].\n     preview-controller-class is preview controller class (extended-preview-controller by default).\n     For other arguments, please see preview-controller and extended-preview-controller :init documentation.\"",
    "\"Reference COG [mm].\"",
    "\"Cart-table system ZMP[mm] as an output variable.\"",
    ":last-refzmp",
    "\"Reference zmp at the last of queue.\"",
    "\"Current reference zmp at the first of queue.\"",
    "\"Update xk and returns zmp and cog values.\n    For arguments, please see preview-controller and extended-preview-controller :update-xk.\"",
    "\"Finished or not.\"",
    "\"Current additional data value.\"",
    "\"Get preview controller results from reference-output-vector-list and returns list.\"",
    "\"COG Z [mm].\"",
    ":update-cog-z",
    "\"(self class zc)\"",
    "(user::robot user::dt user::footstep-node-list user::support-leg-list user::support-leg-coords-list user::swing-leg-dst-coords-list user::swing-leg-src-coords user::refzmp-cur-list user::refzmp-next user::refzmp-prev user::step-height-list user::one-step-len user::index-count user::default-step-height user::default-double-support-ratio user::default-zmp-offsets user::finalize-p user::apreview-controller user::all-limbs user::end-with-double-support user::ik-thre user::ik-rthre user::swing-leg-proj-ratio-interpolation-acc user::swing-leg-proj-ratio-interpolation-vel user::swing-leg-proj-ratio-interpolation-pos user::swing-rot-ratio-interpolation-acc user::swing-rot-ratio-interpolation-vel user::swing-rot-ratio-interpolation-pos)",
    "\"(self class rb _dt)\"",
    "\"(self class fs)\"",
    "\"(self class fs)\"",
    "\"(self class limb-coords limb-names)\"",
    "\"(self class limb-coords limb-names)\"",
    "\"(self class limbs)\"",
    ":initialize-gait-parameter",
    "\"(self class fsl time cog &key ((:default-step-height dsh) 50) ((:default-double-support-ratio ddsr) 0.2) (delay 1.6) ((:all-limbs al) '(:rleg :lleg)) ((:default-zmp-offsets dzo) (mapcan #'(lambda (x) (list x (float-vector 0 0 0))) al)) (q 1.0) (r 1.000000e-06) (thre 1) (rthre (deg2rad 1)) (start-with-double-support t) ((:end-with-double-support ewds) t))\"",
    "\"(self class)\"",
    "\"(self class)\"",
    "\"(self class tmp-remain-time tmp-goal old-acc old-vel old-pos)\"",
    "\"(self class ratio src dst &key (type :shuffling) (step-height default-step-height))\"",
    "\"(self class)\"",
    "\"(self class prev cur next)\"",
    "\"(self class type)\"",
    ":proc-one-tick",
    "\"(self class &key (type :shuffling) (solve-angle-vector :solve-av-by-move-centroid-on-foot) (solve-angle-vector-args) (debug nil))\"",
    "\"(self class)\"",
    "\"(self class support-leg support-leg-coords swing-leg-coords cog &key (solve-angle-vector :solve-av-by-move-centroid-on-foot) (solve-angle-vector-args))\"",
    "\"(self class support-leg support-leg-coords swing-leg-coords cog robot &rest args &key (cog-gain 3.5) (stop 100) (additional-nspace-list) &allow-other-keys)\"",
    "\"(self class ratio start goal height &key (top-ratio 0.5))\"",
    "\"(self class ratio start goal height &key (top-ratio 0.5) (rot-ratio ratio))\"",
    "\"GEOMETRY\"",
    "\"GEOMETRY\"",
    "\"no such package\"",
    ":irtdyna",
    "provide",
  };
